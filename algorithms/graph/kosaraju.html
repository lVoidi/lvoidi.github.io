<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kosaraju's Algorithm: Find Strongly Connected Components | Roarba Portal</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Learn Kosaraju's algorithm with interactive visualization. Understand how to find strongly connected components in directed graphs using depth-first search. Implementations in Python, C++, and C#." />
    <meta name="keywords" content="kosaraju algorithm, strongly connected components, graph algorithms, directed graphs, dfs, graph theory, scc algorithm, graph visualization" />
    <meta name="author" content="Rodrigo Arce" />
    
    <!-- Open Graph / Social Media Tags -->
    <meta property="og:title" content="Kosaraju's Algorithm: Interactive Strongly Connected Components Tutorial" />
    <meta property="og:description" content="Master Kosaraju's algorithm with interactive visualization. Learn how to find strongly connected components in directed graphs using two-pass depth-first search." />
    <meta property="og:image" content="https://roarba.com/static/img/algorithms/kosaraju.jpg" />
    <meta property="og:url" content="https://roarba.com/algorithms/graph/kosaraju.html" />
    <meta property="og:type" content="article" />
    
    <!-- Article Specific Meta Tags -->
    <meta property="article:published_time" content="2025-02-19" />
    <meta property="article:author" content="https://github.com/lVoidi" />
    <meta property="article:section" content="Algorithms" />
    <meta property="article:tag" content="Graph Theory" />
    <meta property="article:tag" content="Graph Algorithms" />
    <meta property="article:tag" content="Connected Components" />
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://roarba.com/algorithms/graph/kosaraju.html" />

    <!-- Schema.org markup for Google -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Kosaraju's Algorithm: Interactive Strongly Connected Components Tutorial",
      "image": "https://roarba.com/static/img/algorithms/kosaraju.jpg",
      "datePublished": "2025-02-19",
      "dateModified": "2025-02-19",
      "author": {
        "@type": "Person",
        "name": "Rodrigo Arce",
        "url": "https://github.com/lVoidi"
      },
      "publisher": {
        "@type": "Person",
        "name": "Rodrigo Arce",
        "url": "https://roarba.com"
      },
      "description": "Comprehensive guide to Kosaraju's algorithm for finding strongly connected components in directed graphs, featuring interactive visualization and multiple programming language implementations.",
      "articleBody": "Kosaraju's algorithm is a linear-time algorithm that uses two depth-first searches to find strongly connected components in directed graphs...",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://roarba.com/algorithms/graph/kosaraju.html"
      },
      "about": {
        "@type": "SoftwareSourceCode",
        "programmingLanguage": ["Python", "C++", "C#"],
        "abstract": "Implementation of Kosaraju's algorithm for finding strongly connected components",
        "codeSampleType": "full"
      },
      "teaches": {
        "@type": "Text",
        "name": "Graph Algorithms",
        "description": "Learn how to find strongly connected components in directed graphs"
      },
      "educationalLevel": "Advanced",
      "timeRequired": "PT35M",
      "interactivityType": "mixed"
    }
    </script>
    
    <!-- CSS imports -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="../../static/css/style.css" rel="stylesheet">
    <link href="../../static/css/algorithms.css" rel="stylesheet">
    <link href="../../static/css/algorithm-page.css" rel="stylesheet">
    <link href="../../static/css/prism.css" rel="stylesheet">
    <link rel="icon" href="../../static/img/icon.png" type="image/x-icon">
</head>
<body>
    <!-- Navbar -->
    <div id="navbar-placeholder"></div>

    <main class="container py-5">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3">
                <div class="algorithm-info-card">
                    <h3>Quick Info</h3>
                    <div class="info-item">
                        <span class="info-label">Category:</span>
                        <span class="info-value">Graph</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Time Complexity:</span>
                        <span class="info-value">O(V + E)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Space Complexity:</span>
                        <span class="info-value">O(V)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Input Type:</span>
                        <span class="info-value">Directed Graph</span>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <article class="algorithm-content">
                    <h1>Kosaraju's Algorithm</h1>
                    <div class="algorithm-metadata">
                        <span class="category-tag">Graph</span>
                        <span class="category-tag">Strongly Connected Components</span>
                        <span class="difficulty-tag">Hard</span>
                    </div>

                    <section class="algorithm-section">
                        <h2>Description</h2>
                        <p>
                            Kosaraju's algorithm is a linear time algorithm to find the strongly connected components (SCCs) 
                            of a directed graph. A strongly connected component is a portion of a directed graph in which there 
                            is a path from each vertex to every other vertex. The algorithm uses depth-first search and works 
                            by performing two passes over the graph.
                        </p>
                    </section>

                    <section class="algorithm-section history-box">
                        <h2>History</h2>
                        <div class="history-content">
                            <img src="../../static/img/kosaraju.jpg" alt="S. Rao Kosaraju" class="history-image">
                            <p>
                                Kosaraju's algorithm was developed by S. Rao Kosaraju in 1978 but was first published 
                                by Micha Sharir in 1981. Kosaraju presented this algorithm during a classroom lecture 
                                at the University of Pennsylvania. The algorithm is notable for its simplicity and 
                                elegance, using two depth-first searches to find strongly connected components.
                                
                                Despite being discovered later than Tarjan's algorithm (1972), which solves the same 
                                problem, Kosaraju's algorithm is often preferred in teaching due to its simpler 
                                conceptual approach, even though both algorithms have the same linear time complexity.
                            </p>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>How It Works</h2>
                        <p>
                            The algorithm works in three main steps:
                        </p>
                        <ol>
                            <li>
                                <strong>First DFS Pass:</strong>
                                <ul>
                                    <li>Perform DFS on the original graph</li>
                                    <li>Store vertices in a stack as they finish (post-order)</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Graph Transposition:</strong>
                                <ul>
                                    <li>Create a new graph by reversing all edges</li>
                                    <li>If edge (u,v) exists in original graph, add (v,u) in transposed graph</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Second DFS Pass:</strong>
                                <ul>
                                    <li>Process vertices in order of the stack (most recently finished first)</li>
                                    <li>Each DFS tree in this pass is a strongly connected component</li>
                                </ul>
                            </li>
                        </ol>
                    </section>

                    <section class="algorithm-section">
                        <h2>Visualization</h2>
                        <div class="visualization-container">
                            <div class="visualization-controls">
                                <button class="btn btn-primary" id="startVisualization">
                                    <i class="fas fa-play"></i> Start
                                </button>
                                <button class="btn btn-secondary" id="resetVisualization">
                                    <i class="fas fa-redo"></i> Reset
                                </button>
                                <div class="speed-control">
                                    <label>Speed:</label>
                                    <input type="range" id="speedControl" min="1" max="5" value="3">
                                </div>
                            </div>
                            <div class="visualization-area">
                                <svg id="kosarajuVisualization"></svg>
                            </div>
                            <div class="visualization-steps">
                                <p id="currentStep">Click Start to begin</p>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Implementation</h2>
                        <div class="implementation-tabs">
                            <ul class="nav nav-tabs" role="tablist">
                                <li class="nav-item">
                                    <a class="nav-link active" data-bs-toggle="tab" href="#python">Python</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#cpp">C++</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#csharp">C#</a>
                                </li>
                            </ul>
                            <div class="tab-content">
                                <!-- Python Implementation -->
                                <div class="tab-pane fade show active" id="python">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#pythonCode">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-python" id="pythonCode">
from collections import defaultdict

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = defaultdict(list)
        
    def add_edge(self, u, v):
        self.graph[u].append(v)
        
    def transpose(self):
        g = Graph(self.V)
        
        for i in self.graph:
            for j in self.graph[i]:
                g.add_edge(j, i)
                
        return g
    
    def fill_order(self, v, visited, stack):
        visited[v] = True
        
        for i in self.graph[v]:
            if not visited[i]:
                self.fill_order(i, visited, stack)
                
        stack.append(v)
    
    def dfs(self, v, visited, scc):
        visited[v] = True
        scc.append(v)
        
        for i in self.graph[v]:
            if not visited[i]:
                self.dfs(i, visited, scc)
    
    def kosaraju(self):
        stack = []
        visited = [False] * self.V
        
        # Fill vertices in stack according to their finishing times
        for i in range(self.V):
            if not visited[i]:
                self.fill_order(i, visited, stack)
        
        # Create a reversed graph
        gr = self.transpose()
        
        # Mark all vertices as not visited for second DFS
        visited = [False] * self.V
        
        # Process all vertices in order defined by stack
        sccs = []
        while stack:
            i = stack.pop()
            if not visited[i]:
                scc = []
                gr.dfs(i, visited, scc)
                sccs.append(scc)
        
        return sccs

# Example usage
if __name__ == "__main__":
    g = Graph(5)
    g.add_edge(1, 0)
    g.add_edge(0, 2)
    g.add_edge(2, 1)
    g.add_edge(0, 3)
    g.add_edge(3, 4)
    
    print("Strongly Connected Components:")
    sccs = g.kosaraju()
    for i, scc in enumerate(sccs, 1):
        print(f"Component {i}: {scc}")
                                        </code></pre>
                                    </div>
                                </div>
                                
                                <!-- C++ Implementation -->
                                <div class="tab-pane fade" id="cpp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#cppCode">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-cpp" id="cppCode">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
using namespace std;

class Graph {
    int V;
    vector&lt;vector&lt;int&gt;&gt; adj;
    
public:
    Graph(int vertices) : V(vertices) {
        adj.resize(V);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }
    
    Graph getTranspose() {
        Graph g(V);
        for(int v = 0; v &lt; V; v++) {
            for(int u : adj[v]) {
                g.addEdge(u, v);
            }
        }
        return g;
    }
    
    void fillOrder(int v, vector&lt;bool&gt;& visited, stack&lt;int&gt;& Stack) {
        visited[v] = true;
        
        for(int i : adj[v]) {
            if(!visited[i]) {
                fillOrder(i, visited, Stack);
            }
        }
        
        Stack.push(v);
    }
    
    void DFSUtil(int v, vector&lt;bool&gt;& visited, vector&lt;int&gt;& scc) {
        visited[v] = true;
        scc.push_back(v);
        
        for(int i : adj[v]) {
            if(!visited[i]) {
                DFSUtil(i, visited, scc);
            }
        }
    }
    
    vector&lt;vector&lt;int&gt;&gt; kosaraju() {
        stack&lt;int&gt; Stack;
        vector&lt;bool&gt; visited(V, false);
        
        // Fill vertices in stack according to their finishing times
        for(int i = 0; i &lt; V; i++) {
            if(!visited[i]) {
                fillOrder(i, visited, Stack);
            }
        }
        
        // Create a reversed graph
        Graph gr = getTranspose();
        
        // Mark all vertices as not visited for second DFS
        fill(visited.begin(), visited.end(), false);
        
        // Process all vertices in order defined by stack
        vector&lt;vector&lt;int&gt;&gt; sccs;
        while(!Stack.empty()) {
            int v = Stack.top();
            Stack.pop();
            
            if(!visited[v]) {
                vector&lt;int&gt; scc;
                gr.DFSUtil(v, visited, scc);
                sccs.push_back(scc);
            }
        }
        
        return sccs;
    }
};

int main() {
    Graph g(5);
    g.addEdge(1, 0);
    g.addEdge(0, 2);
    g.addEdge(2, 1);
    g.addEdge(0, 3);
    g.addEdge(3, 4);
    
    cout &lt;&lt; "Strongly Connected Components:\n";
    auto sccs = g.kosaraju();
    for(int i = 0; i &lt; sccs.size(); i++) {
        cout &lt;&lt; "Component " &lt;&lt; i+1 &lt;&lt; ": ";
        for(int v : sccs[i]) {
            cout &lt;&lt; v &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    
    return 0;
}
                                        </code></pre>
                                    </div>
                                </div>

                                <!-- C# Implementation -->
                                <div class="tab-pane fade" id="csharp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#csharpCode">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-csharp" id="csharpCode">
public class Graph
{
    private int V;
    private List&lt;List&lt;int&gt;&gt; adj;
    
    public Graph(int vertices)
    {
        V = vertices;
        adj = new List&lt;List&lt;int&gt;&gt;();
        for (int i = 0; i &lt; V; i++)
        {
            adj.Add(new List&lt;int&gt;());
        }
    }
    
    public void AddEdge(int u, int v)
    {
        adj[u].Add(v);
    }
    
    private Graph GetTranspose()
    {
        Graph g = new Graph(V);
        for (int v = 0; v &lt; V; v++)
        {
            foreach (int u in adj[v])
            {
                g.AddEdge(u, v);
            }
        }
        return g;
    }
    
    private void FillOrder(int v, bool[] visited, Stack&lt;int&gt; stack)
    {
        visited[v] = true;
        
        foreach (int i in adj[v])
        {
            if (!visited[i])
            {
                FillOrder(i, visited, stack);
            }
        }
        
        stack.Push(v);
    }
    
    private void DFSUtil(int v, bool[] visited, List&lt;int&gt; scc)
    {
        visited[v] = true;
        scc.Add(v);
        
        foreach (int i in adj[v])
        {
            if (!visited[i])
            {
                DFSUtil(i, visited, scc);
            }
        }
    }
    
    public List&lt;List&lt;int&gt;&gt; Kosaraju()
    {
        Stack&lt;int&gt; stack = new Stack&lt;int&gt;();
        bool[] visited = new bool[V];
        
        // Fill vertices in stack according to their finishing times
        for (int i = 0; i &lt; V; i++)
        {
            if (!visited[i])
            {
                FillOrder(i, visited, stack);
            }
        }
        
        // Create a reversed graph
        Graph gr = GetTranspose();
        
        // Mark all vertices as not visited for second DFS
        Array.Fill(visited, false);
        
        // Process all vertices in order defined by stack
        List&lt;List&lt;int&gt;&gt; sccs = new List&lt;List&lt;int&gt;&gt;();
        while (stack.Count &gt; 0)
        {
            int v = stack.Pop();
            
            if (!visited[v])
            {
                List&lt;int&gt; scc = new List&lt;int&gt;();
                gr.DFSUtil(v, visited, scc);
                sccs.Add(scc);
            }
        }
        
        return sccs;
    }
}

public class Program
{
    public static void Main()
    {
        Graph g = new Graph(5);
        g.AddEdge(1, 0);
        g.AddEdge(0, 2);
        g.AddEdge(2, 1);
        g.AddEdge(0, 3);
        g.AddEdge(3, 4);
        
        Console.WriteLine("Strongly Connected Components:");
        var sccs = g.Kosaraju();
        for (int i = 0; i &lt; sccs.Count; i++)
        {
            Console.Write($"Component {i + 1}: ");
            Console.WriteLine(string.Join(" ", sccs[i]));
        }
    }
}
                                        </code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Complexity Analysis</h2>
                        <div class="complexity-analysis">
                            <div class="time-complexity">
                                <h3>Time Complexity</h3>
                                <p>
                                    The time complexity of Kosaraju's algorithm is O(V + E), where V is the number of vertices 
                                    and E is the number of edges in the graph. This can be broken down into:
                                </p>
                                <ul>
                                    <li>
                                        <strong>First DFS:</strong> O(V + E)
                                        <ul>
                                            <li>Visits each vertex once: O(V)</li>
                                            <li>Traverses each edge once: O(E)</li>
                                        </ul>
                                    </li>
                                    <li>
                                        <strong>Graph Transposition:</strong> O(V + E)
                                        <ul>
                                            <li>Creating new adjacency list: O(V)</li>
                                            <li>Copying and reversing edges: O(E)</li>
                                        </ul>
                                    </li>
                                    <li>
                                        <strong>Second DFS:</strong> O(V + E)
                                        <ul>
                                            <li>Visits each vertex once: O(V)</li>
                                            <li>Traverses each edge once: O(E)</li>
                                        </ul>
                                    </li>
                                </ul>
                                <p>
                                    Total: O(V + E) + O(V + E) + O(V + E) = O(V + E)
                                </p>
                            </div>
                            
                            <div class="space-complexity">
                                <h3>Space Complexity</h3>
                                <p>
                                    The space complexity is O(V), which includes:
                                </p>
                                <ul>
                                    <li>
                                        <strong>Visited Array:</strong> O(V)
                                        <ul>
                                            <li>Boolean array to track visited vertices</li>
                                        </ul>
                                    </li>
                                    <li>
                                        <strong>Stack:</strong> O(V)
                                        <ul>
                                            <li>Stores vertices in order of finish time</li>
                                        </ul>
                                    </li>
                                    <li>
                                        <strong>Transposed Graph:</strong> O(V + E)
                                        <ul>
                                            <li>New adjacency list structure</li>
                                            <li>Reversed edges</li>
                                        </ul>
                                    </li>
                                    <li>
                                        <strong>Output Storage:</strong> O(V)
                                        <ul>
                                            <li>Storage for strongly connected components</li>
                                        </ul>
                                    </li>
                                </ul>
                                <p>
                                    While the transposed graph requires O(V + E) space, the original space complexity is 
                                    typically cited as O(V) since we assume the input graph already uses O(V + E) space.
                                </p>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Advantages and Disadvantages</h2>
                        <div class="pros-cons">
                            <div class="pros">
                                <h3>Advantages</h3>
                                <ul>
                                    <li>Linear time complexity O(V + E)</li>
                                    <li>Simple conceptual understanding</li>
                                    <li>Easy to implement</li>
                                    <li>Useful for graph analysis</li>
                                </ul>
                            </div>
                            <div class="cons">
                                <h3>Disadvantages</h3>
                                <ul>
                                    <li>Requires two graph traversals</li>
                                    <li>Needs to store the transpose graph</li>
                                    <li>Not as space-efficient as Tarjan's algorithm</li>
                                    <li>Not suitable for dynamic graphs</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </article>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <div id="footer-placeholder"></div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="../../static/js/prism.js"></script>
    <script src="../../static/js/kosaraju-visualization.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const clipboard = new ClipboardJS('.copy-button');
            
            clipboard.on('success', (e) => {
                const button = e.trigger;
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => {
                    button.innerHTML = '<i class="fas fa-copy"></i>';
                }, 2000);
                e.clearSelection();
            });
        });
    </script>
    <script src="../../static/js/templates.js"></script>
</body>
</html> 