<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Algorithm - lVoidi Portal</title>
    
    <!-- CSS imports -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="../../static/css/style.css" rel="stylesheet">
    <link href="../../static/css/algorithms.css" rel="stylesheet">
    <link href="../../static/css/algorithm-page.css" rel="stylesheet">
    <link href="../../static/css/prism.css" rel="stylesheet">

    <!-- Icon -->
    <link rel="icon" href="../../static/img/icon.png" type="image/x-icon">
</head>
<body>

    <nav class="navbar navbar-expand-lg navbar-dark sticky-top">
        <div class="container">
            <a class="navbar-brand" href="../../index.html">lVoidi</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link active" href="../index.html">Algorithms</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../../singularity/index.html">Technological Singularity</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../../void/index.html">The Pit of Endless Void</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    
    <main class="container py-5">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3">
                <div class="algorithm-info-card">
                    <h3>Quick Info</h3>
                    <div class="info-item">
                        <span class="info-label">Category:</span>
                        <span class="info-value">Pathfinding</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Time Complexity:</span>
                        <span class="info-value">O(E log V)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Space Complexity:</span>
                        <span class="info-value">O(V)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Input Type:</span>
                        <span class="info-value">Grid/Graph</span>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <article class="algorithm-content">
                    <h1>A* (A-Star) Algorithm</h1>
                    <div class="algorithm-metadata">
                        <span class="category-tag">Pathfinding</span>
                        <span class="difficulty-tag">Medium</span>
                    </div>

                    <section class="algorithm-section">
                        <h2>Description</h2>
                        <p>A* is an informed search algorithm that finds the shortest path between nodes in a graph. Unlike Dijkstra's algorithm, A* uses heuristics to guide its search, making it more efficient for many practical applications.</p>
                    </section>
                    <section class="algorithm-section history-box">
                        <h2>History</h2>
                        <div class="history-content">
                            <img src="../../static/img/hart.jpg" alt="Peter Hart" class="history-image">
                            <p>
                                The A* (pronounced "A-star") algorithm was created in 1968 by Peter Hart, Nils Nilsson, 
                                and Bertram Raphael at the Stanford Research Institute (now SRI International). It was 
                                developed as part of the Shakey robotics project, which aimed to build a mobile robot 
                                that could plan its own actions.

                                A* was a significant improvement over existing pathfinding algorithms like Dijkstra's 
                                algorithm because it incorporated heuristics to guide the search process more efficiently. 
                                The algorithm was first described in their 1968 paper "A Formal Basis for the Heuristic 
                                Determination of Minimum Cost Paths," which has become one of the most cited papers in 
                                computer science.

                                The key innovation of A* was combining Dijkstra's algorithm with heuristic estimation 
                                (similar to what was used in Breadth-First Search) to create an algorithm that was both 
                                optimal and efficient. The name "A*" was chosen because it was an improvement over their 
                                previous algorithm called "A1", and the asterisk represented that it was optimal under 
                                appropriate conditions.

                                Since its introduction, A* has become the foundation for many pathfinding applications, 
                                from video games to robotics. Its influence extends beyond just pathfinding - the 
                                principles behind A* have inspired many other informed search algorithms and continue 
                                to influence artificial intelligence research today.
                            </p>
                        </div>
                    </section>
                    <section class="algorithm-section">
                        <h2>How It Works</h2>
                        <ol>
                            <li>Initialize the open list with the starting node</li>
                            <li>For each node, maintain:
                                <ul>
                                    <li>g(n): Cost from start to current node</li>
                                    <li>h(n): Estimated cost from current node to goal</li>
                                    <li>f(n) = g(n) + h(n): Total estimated cost</li>
                                </ul>
                            </li>
                            <li>While the open list is not empty:
                                <ol type="a">
                                    <li>Get node with lowest f(n) from open list</li>
                                    <li>If current node is goal, reconstruct path</li>
                                    <li>Generate successors and calculate their scores</li>
                                    <li>Add successors to open list if better path found</li>
                                </ol>
                            </li>
                        </ol>
                    </section>

                    <section class="algorithm-section">
                        <h2>Visualization</h2>
                        <div class="visualization-container">
                            <div class="visualization-controls">
                                <div class="control-group">
                                    <button class="btn btn-primary" id="startVisualization">
                                        <i class="fas fa-play"></i> Start
                                    </button>
                                    <button class="btn btn-secondary" id="resetVisualization">
                                        <i class="fas fa-redo"></i> Reset
                                    </button>
                                    <button class="btn btn-info" id="generateMaze">
                                        <i class="fas fa-magic"></i> Generate Maze
                                    </button>
                                </div>
                                <div class="speed-control">
                                    <label>Speed:</label>
                                    <input type="range" id="speedControl" min="1" max="5" value="3">
                                </div>
                            </div>
                            <div class="grid-container">
                                <div id="astarGrid" class="grid"></div>
                            </div>
                            <div class="visualization-steps">
                                <p id="currentStep">Click on the grid to set start and end points</p>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Implementation</h2>
                        <div class="implementation-container">
                            <div class="implementation-tabs">
                                <ul class="nav nav-tabs" role="tablist">
                                    <li class="nav-item">
                                        <a class="nav-link active" data-bs-toggle="tab" href="#python">Python</a>
                                    </li>
                                    <li class="nav-item">
                                        <a class="nav-link" data-bs-toggle="tab" href="#cpp">C++</a>
                                    </li>
                                    <li class="nav-item">
                                        <a class="nav-link" data-bs-toggle="tab" href="#csharp">C#</a>
                                    </li>
                                </ul>
                                
                                <div class="tab-content">
                                    <!-- Python Implementation -->
                                    <div class="tab-pane fade show active" id="python">
                                        <div class="code-wrapper">
                                            <button class="copy-button" data-clipboard-target="#python-code">
                                                <i class="fas fa-copy"></i>
                                            </button>
                                            <pre><code class="language-python" id="python-code">
from heapq import heappush, heappop
from dataclasses import dataclass, field
from typing import List, Set, Dict, Tuple

@dataclass
class Node:
    x: int
    y: int
    f: float = 0.0
    g: float = 0.0
    h: float = 0.0
    parent: 'Node' = None
    
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
    
    def __lt__(self, other):
        return self.f < other.f
    
    def __hash__(self):
        return hash((self.x, self.y))

class AStar:
    @staticmethod
    def heuristic(a: Node, b: Node) -> float:
        # Manhattan distance
        return abs(a.x - b.x) + abs(a.y - b.y)
    
    @staticmethod
    def is_valid(x: int, y: int, rows: int, cols: int) -> bool:
        return 0 <= x < rows and 0 <= y < cols
    
    @staticmethod
    def find_path(grid: List[List[bool]], start_pos: Tuple[int, int], 
                  end_pos: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Find the shortest path using A* algorithm
        
        Args:
            grid: 2D grid where True represents walls/obstacles
            start_pos: Starting position (x, y)
            end_pos: Target position (x, y)
            
        Returns:
            List of coordinates representing the path
        """
        rows, cols = len(grid), len(grid[0])
        start_x, start_y = start_pos
        end_x, end_y = end_pos
        
        # Create start and end nodes
        start_node = Node(start_x, start_y)
        end_node = Node(end_x, end_y)
        
        # Initialize open and closed sets
        open_set: List[Node] = []
        closed_set: Set[Node] = set()
        
        # Add start node to open set
        heappush(open_set, start_node)
        
        # Define possible movements (up, down, left, right)
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        while open_set:
            current = heappop(open_set)
            
            if current == end_node:
                path = []
                while current:
                    path.append((current.x, current.y))
                    current = current.parent
                return path[::-1]
            
            closed_set.add(current)
            
            # Check all neighboring nodes
            for dx, dy in directions:
                new_x, new_y = current.x + dx, current.y + dy
                
                # Skip if position is invalid or is a wall
                if not AStar.is_valid(new_x, new_y, rows, cols) or grid[new_x][new_y]:
                    continue
                
                neighbor = Node(new_x, new_y)
                
                # Skip if node has been evaluated
                if neighbor in closed_set:
                    continue
                
                # Calculate g, h, and f values
                tentative_g = current.g + 1
                
                # Check if this path is better than previous ones
                if neighbor not in open_set or tentative_g < neighbor.g:
                    neighbor.parent = current
                    neighbor.g = tentative_g
                    neighbor.h = AStar.heuristic(neighbor, end_node)
                    neighbor.f = neighbor.g + neighbor.h
                    
                    if neighbor not in open_set:
                        heappush(open_set, neighbor)
        
        return []  # No path found
    
    @staticmethod
    def print_path(path: List[Tuple[int, int]]):
        """Print the path coordinates"""
        print(" -> ".join(f"({x},{y})" for x, y in path))

# Example usage
if __name__ == "__main__":
    # Create a sample grid (False = empty, True = wall)
    grid = [
        [False, False, False, False, False],
        [True,  True,  False, True,  False],
        [False, False, False, False, False],
        [False, True,  True,  True,  False],
        [False, False, False, False, False]
    ]
    
    start = (0, 0)
    end = (4, 4)
    
    path = AStar.find_path(grid, start, end)
    
    if path:
        print("Path found:")
        AStar.print_path(path)
    else:
        print("No path found!")
                                            </code></pre>
                                        </div>
                                    </div>
                                    
                                    <!-- C++ Implementation -->
                                    <div class="tab-pane fade" id="cpp">
                                        <div class="code-wrapper">
                                            <button class="copy-button" data-clipboard-target="#cpp-code">
                                                <i class="fas fa-copy"></i>
                                            </button>
                                            <pre><code class="language-cpp" id="cpp-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;unordered_set&gt;

class AStar {
private:
    struct Node {
        int x, y;
        double f, g, h;
        Node* parent;
        
        Node(int x, int y) : x(x), y(y), f(0), g(0), h(0), parent(nullptr) {}
        
        bool operator==(const Node& other) const {
            return x == other.x && y == other.y;
        }
    };
    
    struct NodeCompare {
        bool operator()(const Node* a, const Node* b) const {
            return a->f > b->f;
        }
    };
    
    static double heuristic(const Node* a, const Node* b) {
        // Manhattan distance
        return std::abs(a->x - b->x) + std::abs(a->y - b->y);
    }
    
    static bool isValid(int x, int y, int rows, int cols) {
        return x >= 0 && x < rows && y >= 0 && y < cols;
    }
    
    static void printPath(const std::vector<std::pair<int, int>>& path) {
        for (const auto& [x, y] : path) {
            std::cout << "(" << x << "," << y << ") ";
        }
        std::cout << std::endl;
    }

public:
    static std::vector<std::pair<int, int>> findPath(
        const std::vector<std::vector<bool>>& grid,
        int startX, int startY,
        int endX, int endY
    ) {
        const int rows = grid.size();
        const int cols = grid[0].size();
        
        std::priority_queue<Node*, std::vector<Node*>, NodeCompare> openSet;
        std::unordered_set<Node*> closedSet;
        
        Node* startNode = new Node(startX, startY);
        Node* endNode = new Node(endX, endY);
        
        openSet.push(startNode);
        
        const std::vector<std::pair<int, int>> directions = {
            {-1, 0}, {1, 0}, {0, -1}, {0, 1}
        };
        
        while (!openSet.empty()) {
            Node* current = openSet.top();
            openSet.pop();
            
            if (*current == *endNode) {
                std::vector<std::pair<int, int>> path;
                while (current != nullptr) {
                    path.push_back({current->x, current->y});
                    current = current->parent;
                }
                std::reverse(path.begin(), path.end());
                return path;
            }
            
            closedSet.insert(current);
            
            for (const auto& [dx, dy] : directions) {
                int newX = current->x + dx;
                int newY = current->y + dy;
                
                if (!isValid(newX, newY, rows, cols) || grid[newX][newY]) {
                    continue;
                }
                
                Node* neighbor = new Node(newX, newY);
                if (closedSet.find(neighbor) != closedSet.end()) {
                    delete neighbor;
                    continue;
                }
                
                double tentativeG = current->g + 1;
                
                neighbor->parent = current;
                neighbor->g = tentativeG;
                neighbor->h = heuristic(neighbor, endNode);
                neighbor->f = neighbor->g + neighbor->h;
                
                openSet.push(neighbor);
            }
        }
        
        return std::vector<std::pair<int, int>>();
    }
};
                                        </code></pre>
                                        </div>
                                    </div>
                                    
                                    <!-- C# Implementation -->
                                    <div class="tab-pane fade" id="csharp">
                                        <div class="code-wrapper">
                                            <button class="copy-button" data-clipboard-target="#csharp-code">
                                                <i class="fas fa-copy"></i>
                                            </button>
                                            <pre><code class="language-csharp" id="csharp-code">
using System;
using System.Collections.Generic;
using System.Linq;

public class AStar
{
    private class Node
    {
        public int X { get; }
        public int Y { get; }
        public double F { get; set; }
        public double G { get; set; }
        public double H { get; set; }
        public Node Parent { get; set; }
        
        public Node(int x, int y)
        {
            X = x;
            Y = y;
            F = G = H = 0;
            Parent = null;
        }
        
        public override bool Equals(object obj)
        {
            if (obj is Node other)
            {
                return X == other.X && Y == other.Y;
            }
            return false;
        }
        
        public override int GetHashCode()
        {
            return HashCode.Combine(X, Y);
        }
    }
    
    private static double Heuristic(Node a, Node b)
    {
        // Manhattan distance
        return Math.Abs(a.X - b.X) + Math.Abs(a.Y - b.Y);
    }
    
    private static bool IsValid(int x, int y, int rows, int cols)
    {
        return x >= 0 && x < rows && y >= 0 && y < cols;
    }
    
    public static List<(int, int)> FindPath(
        bool[,] grid,
        int startX, int startY,
        int endX, int endY)
    {
        var rows = grid.GetLength(0);
        var cols = grid.GetLength(1);
        
        var openSet = new SortedSet<Node>(Comparer<Node>.Create((a, b) =>
            a.F != b.F ? a.F.CompareTo(b.F) : a.GetHashCode().CompareTo(b.GetHashCode())));
            
        var closedSet = new HashSet<Node>();
        
        var startNode = new Node(startX, startY);
        var endNode = new Node(endX, endY);
        
        openSet.Add(startNode);
        
        var directions = new[]
        {
            (-1, 0), (1, 0), (0, -1), (0, 1)
        };
        
        while (openSet.Count > 0)
        {
            var current = openSet.Min;
            openSet.Remove(current);
            
            if (current.Equals(endNode))
            {
                var path = new List<(int, int)>();
                while (current != null)
                {
                    path.Add((current.X, current.Y));
                    current = current.Parent;
                }
                path.Reverse();
                return path;
            }
            
            closedSet.Add(current);
            
            foreach (var (dx, dy) in directions)
            {
                var newX = current.X + dx;
                var newY = current.Y + dy;
                
                if (!IsValid(newX, newY, rows, cols) || grid[newX, newY])
                {
                    continue;
                }
                
                var neighbor = new Node(newX, newY);
                if (closedSet.Contains(neighbor))
                {
                    continue;
                }
                
                var tentativeG = current.G + 1;
                
                neighbor.Parent = current;
                neighbor.G = tentativeG;
                neighbor.H = Heuristic(neighbor, endNode);
                neighbor.F = neighbor.G + neighbor.H;
                
                openSet.Add(neighbor);
            }
        }
        
        return new List<(int, int)>();
    }
    
    public static void PrintPath(List<(int, int)> path)
    {
        foreach (var (x, y) in path)
        {
            Console.Write($"({x},{y}) ");
        }
        Console.WriteLine();
    }
}
                                        </code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Complexity Analysis</h2>
                        <div class="complexity-analysis">
                            <div class="complexity-item">
                                <h3>Time Complexity</h3>
                                <p><strong>O((V + E) log V)</strong> where:</p>
                                <ul>
                                    <li>V is the number of vertices (nodes)</li>
                                    <li>E is the number of edges</li>
                                    <li>log V comes from the priority queue operations</li>
                                </ul>
                                <p>Note: In a grid-based implementation, where each cell connects to its neighbors, the complexity can be expressed as O(n log n) where n is the number of cells.</p>
                            </div>
                            
                            <div class="complexity-item">
                                <h3>Space Complexity</h3>
                                <p><strong>O(V)</strong> where:</p>
                                <ul>
                                    <li>V is the number of vertices (nodes)</li>
                                    <li>Space is needed for the open and closed sets</li>
                                    <li>Additional space for the path reconstruction</li>
                                </ul>
                            </div>
                            
                            <div class="complexity-item">
                                <h3>Best Case</h3>
                                <p>O(1) when the target is the starting node or immediately adjacent.</p>
                            </div>
                            
                            <div class="complexity-item">
                                <h3>Worst Case</h3>
                                <p>O((V + E) log V) when the algorithm needs to explore most of the graph before finding the target.</p>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Advantages and Disadvantages</h2>
                        <div class="pros-cons">
                            <div class="pros">
                                <h3>Advantages</h3>
                                <ul>
                                    <li>More efficient than Dijkstra's algorithm for most pathfinding scenarios</li>
                                    <li>Guarantees the shortest path when using an admissible heuristic</li>
                                    <li>Can be optimized with different heuristics for specific use cases</li>
                                    <li>Widely used in games and robotics</li>
                                    <li>Can handle both weighted and unweighted graphs</li>
                                    <li>Easy to modify for different movement patterns</li>
                                </ul>
                            </div>
                            
                            <div class="cons">
                                <h3>Disadvantages</h3>
                                <ul>
                                    <li>Memory intensive for large graphs</li>
                                    <li>Performance depends heavily on the heuristic function</li>
                                    <li>May not perform well in maze-like environments with many obstacles</li>
                                    <li>Can be slower than other algorithms when the heuristic is poor</li>
                                    <li>More complex to implement than simpler algorithms like BFS</li>
                                    <li>May explore unnecessary nodes if the heuristic overestimates</li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Common Applications</h2>
                        <ul class="applications-list">
                            <li>Video game pathfinding (NPCs, navigation)</li>
                            <li>Robotics and autonomous navigation</li>
                            <li>GPS and navigation systems</li>
                            <li>Network routing</li>
                            <li>Puzzle solving (8-puzzle, sliding puzzles)</li>
                            <li>Automated planning systems</li>
                        </ul>
                    </section>
                </article>
            </div>
        </div>
    </main>
    <footer class="footer mt-auto py-4">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-6 text-center text-md-start">
                    <p class="mb-0">&copy; 2024 lVoidi. All rights reserved.</p>
                </div>
                <div class="col-md-6">
                    <ul class="social-links list-inline mb-0 text-center text-md-end">
                        <li class="list-inline-item">
                            <a href="https://github.com/lVoidi" target="_blank" rel="noopener noreferrer" 
                               class="social-link" aria-label="GitHub">
                                <i class="fab fa-github"></i>
                            </a>
                        </li>
                        <li class="list-inline-item">
                            <a href="https://linkedin.com/in/roarba" target="_blank" rel="noopener noreferrer" 
                               class="social-link" aria-label="LinkedIn">
                                <i class="fab fa-linkedin"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </footer>
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script src="../../static/js/prism.js"></script>
    <script src="../../static/js/astar-visualization.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const clipboard = new ClipboardJS('.copy-button');
            
            clipboard.on('success', (e) => {
                const button = e.trigger;
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => {
                    button.innerHTML = '<i class="fas fa-copy"></i>';
                }, 2000);
                e.clearSelection();
            });
        });
    </script>
</body>
</html> 