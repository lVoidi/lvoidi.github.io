<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Coding - lVoidi Portal</title>
    
    <!-- CSS imports -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="../../static/css/style.css" rel="stylesheet">
    <link href="../../static/css/algorithms.css" rel="stylesheet">
    <link href="../../static/css/algorithm-page.css" rel="stylesheet">
    <link href="../../static/css/prism.css" rel="stylesheet">
    <link rel="icon" href="../../static/img/icon.png" type="image/x-icon">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark sticky-top"></nav>
      <div class="container">
        <a class="navbar-brand" href="../../index.html">lVoidi</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav ms-auto">
            <li class="nav-item">
              <a class="nav-link active" href="../index.html">Algorithms</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../../singularity/index.html">Technological Singularity</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../../void/index.html">The Pit of Endless Void</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <main class="container py-5">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3">
                <div class="algorithm-info-card">
                    <h3>Quick Info</h3>
                    <div class="info-item">
                        <span class="info-label">Category:</span>
                        <span class="info-value">Greedy</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Time Complexity:</span>
                        <span class="info-value">O(n log n)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Space Complexity:</span>
                        <span class="info-value">O(n)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Input Type:</span>
                        <span class="info-value">String/Frequency Table</span>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <article class="algorithm-content">
                    <h1>Huffman Coding</h1>
                    <div class="algorithm-metadata">
                        <span class="category-tag">Greedy</span>
                        <span class="difficulty-tag">Medium</span>
                    </div>

                    <section class="algorithm-section">
                        <h2>Description</h2>
                        <p>
                            Huffman coding is a data compression technique that uses variable-length codes to represent characters based on their frequency of occurrence. More frequent characters are assigned shorter codes, while less frequent characters receive longer codes, resulting in efficient data compression.
                        </p>
                    </section>

                    <section class="algorithm-section history-box">
                        <h2>History</h2>
                        <div class="history-content">
                            <img src="../../static/img/huffman.jpg" alt="David A. Huffman" class="history-image">
                            <p>
                                Huffman coding was developed by David A. Huffman while he was a graduate student at MIT in 1952. 
                                The algorithm came about as a result of a term paper assignment in an Information Theory class 
                                taught by Robert M. Fano. Fano had been working on a similar problem with Claude Shannon, 
                                and had developed the Shannon-Fano coding.
                                
                                When given the assignment, Huffman worked on the problem for months until he finally came up 
                                with a more efficient solution than the existing Shannon-Fano coding. His professor, Robert Fano, 
                                was impressed and helped Huffman publish his findings. The paper, "A Method for the Construction 
                                of Minimum-Redundancy Codes", was published in the Proceedings of the IRE in 1952 and became 
                                one of the most cited papers in computer science.
                                
                                Today, Huffman coding is used in various file compression formats including JPEG, PNG, and MP3, 
                                and serves as a fundamental building block in many modern data compression algorithms.
                            </p>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>How It Works</h2>
                        <ol>
                            <li>Calculate the frequency of each character in the input</li>
                            <li>Create a leaf node for each character and add it to a priority queue</li>
                            <li>While there is more than one node in the queue:</li>
                            <ol type="a">
                                <li>Remove the two nodes with lowest frequency</li>
                                <li>Create a new internal node with these nodes as children</li>
                                <li>Add the new node back to the queue</li>
                            </ol>
                            <li>The remaining node is the root of the Huffman tree</li>
                            <li>Traverse the tree to assign codes (left=0, right=1)</li>
                        </ol>
                        <h2>Visualization</h2>
                        <div class="visualization-container">
                            <div class="visualization-controls">
                                <div class="input-group mb-3">
                                    <input type="text" id="textInput" class="form-control" 
                                        placeholder="Enter text to compress" value="hello world">
                                    <button class="btn btn-primary" id="startVisualization">
                                        <i class="fas fa-play"></i> Start
                                    </button>
                                    <button class="btn btn-secondary" id="resetVisualization">
                                        <i class="fas fa-redo"></i> Reset
                                    </button>
                                </div>
                                <div class="speed-control">
                                    <label>Speed:</label>
                                    <input type="range" id="speedControl" min="1" max="5" value="3">
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-4">
                                    <table class="table" id="frequencyTable">
                                        <thead>
                                            <tr>
                                                <th>Character</th>
                                                <th>Frequency</th>
                                                <th>Code</th>
                                            </tr>
                                        </thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                <div class="col-md-8">
                                    <div class="visualization-area">
                                        <svg id="huffmanVisualization" width="100%" height="500"></svg>
                                    </div>
                                </div>
                            </div>
                            <div class="visualization-steps">
                                <p id="currentStep">Enter text and click Start</p>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Advantages and Disadvantages</h2>
                        <div class="pros-cons">
                            <div class="pros">
                                <h3>Advantages</h3>
                                <ul>
                                    <li>Provides optimal prefix codes</li>
                                    <li>Lossless compression</li>
                                    <li>Simple and efficient implementation</li>
                                    <li>Widely used in practice</li>
                                </ul>
                            </div>
                            <div class="cons">
                                <h3>Disadvantages</h3>
                                <ul>
                                    <li>Requires two passes over the data</li>
                                    <li>Need to store the tree structure</li>
                                    <li>Not optimal for adaptive compression</li>
                                    <li>May not compress well with uniform frequency distribution</li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Implementation</h2>
                        <div class="implementation-tabs">
                            <ul class="nav nav-tabs" role="tablist">
                                <li class="nav-item">
                                    <a class="nav-link active" data-bs-toggle="tab" href="#python">Python</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#cpp">C++</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#csharp">C#</a>
                                </li>
                            </ul>
                            <div class="tab-content">
                                <!-- Python Implementation -->
                                <div class="tab-pane fade show active" id="python">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#pythonCode">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-python" id="pythonCode">
from heapq import heappush, heappop
from collections import defaultdict

class HuffmanNode:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None
        
    def __lt__(self, other):
        return self.freq < other.freq

def build_huffman_tree(text):
    # Calculate frequency of each character
    frequency = defaultdict(int)
    for char in text:
        frequency[char] += 1
    
    # Create priority queue
    heap = []
    for char, freq in frequency.items():
        heappush(heap, HuffmanNode(char, freq))
    
    # Build the Huffman tree
    while len(heap) > 1:
        left = heappop(heap)
        right = heappop(heap)
        
        internal = HuffmanNode(None, left.freq + right.freq)
        internal.left = left
        internal.right = right
        
        heappush(heap, internal)
    
    return heap[0] if heap else None

def generate_codes(root, code="", codes=None):
    if codes is None:
        codes = {}
    
    if root is None:
        return codes
    
    if root.char is not None:
        codes[root.char] = code
        return codes
    
    generate_codes(root.left, code + "0", codes)
    generate_codes(root.right, code + "1", codes)
    return codes

def huffman_encoding(text):
    # Handle empty text
    if not text:
        return "", None
    
    # Handle text with only one unique character
    if len(set(text)) == 1:
        return "0" * len(text), {text[0]: "0"}
    
    # Build Huffman tree
    root = build_huffman_tree(text)
    
    # Generate codes
    codes = generate_codes(root)
    
    # Encode text
    encoded = "".join(codes[char] for char in text)
    
    return encoded, codes

def huffman_decoding(encoded_text, codes):
    if not encoded_text:
        return ""
    
    # Create reverse lookup
    reverse_codes = {code: char for char, code in codes.items()}
    
    # Decode text
    current_code = ""
    decoded = []
    
    for bit in encoded_text:
        current_code += bit
        if current_code in reverse_codes:
            decoded.append(reverse_codes[current_code])
            current_code = ""
    
    return "".join(decoded)

# Example usage
if __name__ == "__main__":
    text = "hello world"
    print(f"Original text: {text}")
    
    encoded, codes = huffman_encoding(text)
    print(f"\nHuffman Codes:")
    for char, code in codes.items():
        print(f"'{char}': {code}")
    
    print(f"\nEncoded text: {encoded}")
    
    decoded = huffman_decoding(encoded, codes)
    print(f"Decoded text: {decoded}")
                                        </code></pre>
                                    </div>
                                </div>
                                
                                <!-- C++ Implementation -->
                                <div class="tab-pane fade" id="cpp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#cppCode">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-cpp" id="cppCode">
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

class HuffmanNode {
public:
    char character;
    int frequency;
    HuffmanNode* left;
    HuffmanNode* right;
    
    HuffmanNode(char c, int f) : 
        character(c), frequency(f), left(nullptr), right(nullptr) {}
};

struct CompareNodes {
    bool operator()(HuffmanNode* a, HuffmanNode* b) {
        return a-&gt;frequency &gt; b-&gt;frequency;
    }
};

class HuffmanCoding {
private:
    HuffmanNode* root;
    std::unordered_map&lt;char, std::string&gt; codes;
    
    void generateCodes(HuffmanNode* node, std::string code) {
        if (!node) return;
        
        if (!node->left && !node->right) {
            codes[node->character] = code;
            return;
        }
        
        generateCodes(node->left, code + "0");
        generateCodes(node->right, code + "1");
    }
    
    void cleanup(HuffmanNode* node) {
        if (!node) return;
        cleanup(node->left);
        cleanup(node->right);
        delete node;
    }

public:
    HuffmanCoding() : root(nullptr) {}
    ~HuffmanCoding() { cleanup(root); }
    
    std::pair&lt;std::string, std::unordered_map&lt;char, std::string&gt;&gt; 
    encode(const std::string& text) {
        // Calculate frequencies
        std::unordered_map&lt;char, int&gt; freq;
        for (char c : text) freq[c]++;
        
        // Create min heap
        std::priority_queue&lt;HuffmanNode*, std::vector&lt;HuffmanNode*&gt;, 
                          CompareNodes&gt; minHeap;
                          
        for (const auto& pair : freq) {
            minHeap.push(new HuffmanNode(pair.first, pair.second));
        }
        
        // Build Huffman tree
        while (minHeap.size() > 1) {
            HuffmanNode* left = minHeap.top(); minHeap.pop();
            HuffmanNode* right = minHeap.top(); minHeap.pop();
            
            HuffmanNode* internal = new HuffmanNode('\0', 
                left->frequency + right->frequency);
            internal->left = left;
            internal->right = right;
            
            minHeap.push(internal);
        }
        
        root = minHeap.top();
        
        // Generate codes
        codes.clear();
        generateCodes(root, "");
        
        // Encode text
        std::string encoded;
        for (char c : text) {
            encoded += codes[c];
        }
        
        return {encoded, codes};
    }
    
    std::string decode(const std::string& encoded, 
                      const std::unordered_map&lt;char, std::string&gt;& codes) {
        // Create reverse lookup
        std::unordered_map&lt;std::string, char&gt; reverseMap;
        for (const auto& pair : codes) {
            reverseMap[pair.second] = pair.first;
        }
        
        std::string current;
        std::string decoded;
        
        for (char bit : encoded) {
            current += bit;
            if (reverseMap.count(current)) {
                decoded += reverseMap[current];
                current.clear();
            }
        }
        
        return decoded;
    }
};

int main() {
    std::string text = "hello world";
    std::cout << "Original text: " << text << std::endl;
    
    HuffmanCoding huffman;
    auto [encoded, codes] = huffman.encode(text);
    
    std::cout << "\nHuffman Codes:" << std::endl;
    for (const auto& [c, code] : codes) {
        std::cout << "'" << c << "': " << code << std::endl;
    }
    
    std::cout << "\nEncoded text: " << encoded << std::endl;
    
    std::string decoded = huffman.decode(encoded, codes);
    std::cout << "Decoded text: " << decoded << std::endl;
    
    return 0;
}
                                        </code></pre>
                                    </div>
                                </div>
                                
                                <!-- C# Implementation -->
                                <div class="tab-pane fade" id="csharp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#csharpCode">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-csharp" id="csharpCode">
using System;
using System.Collections.Generic;
using System.Linq;

public class HuffmanNode : IComparable&lt;HuffmanNode&gt;
{
    public char? Character { get; set; }
    public int Frequency { get; set; }
    public HuffmanNode Left { get; set; }
    public HuffmanNode Right { get; set; }
    
    public HuffmanNode(char? c, int freq)
    {
        Character = c;
        Frequency = freq;
        Left = null;
        Right = null;
    }
    
    public int CompareTo(HuffmanNode other)
    {
        return Frequency.CompareTo(other.Frequency);
    }
}

public class HuffmanCoding
{
    private HuffmanNode root;
    private Dictionary&lt;char, string&gt; codes;
    
    public HuffmanCoding()
    {
        root = null;
        codes = new Dictionary&lt;char, string&gt;();
    }
    
    private void GenerateCodes(HuffmanNode node, string code)
    {
        if (node == null) return;
        
        if (node.Character.HasValue)
        {
            codes[node.Character.Value] = code;
            return;
        }
        
        GenerateCodes(node.Left, code + "0");
        GenerateCodes(node.Right, code + "1");
    }
    
    public (string encoded, Dictionary&lt;char, string&gt; codes) Encode(string text)
    {
        // Calculate frequencies
        var frequencies = text.GroupBy(c =&gt; c)
                            .ToDictionary(g =&gt; g.Key, g =&gt; g.Count());
        
        // Create priority queue
        var priorityQueue = new SortedSet&lt;HuffmanNode&gt;();
        foreach (var pair in frequencies)
        {
            priorityQueue.Add(new HuffmanNode(pair.Key, pair.Value));
        }
        
        // Build Huffman tree
        while (priorityQueue.Count &gt; 1)
        {
            var left = priorityQueue.Min;
            priorityQueue.Remove(left);
            var right = priorityQueue.Min;
            priorityQueue.Remove(right);
            
            var internal = new HuffmanNode(null, left.Frequency + right.Frequency)
            {
                Left = left,
                Right = right
            };
            
            priorityQueue.Add(internal);
        }
        
        root = priorityQueue.Any() ? priorityQueue.Min : null;
        
        // Generate codes
        codes.Clear();
        GenerateCodes(root, "");
        
        // Encode text
        var encoded = string.Concat(text.Select(c =&gt; codes[c]));
        
        return (encoded, new Dictionary&lt;char, string&gt;(codes));
    }
    
    public string Decode(string encoded, Dictionary&lt;char, string&gt; codes)
    {
        if (string.IsNullOrEmpty(encoded)) return "";
        
        // Create reverse lookup
        var reverseMap = codes.ToDictionary(pair =&gt; pair.Value, pair =&gt; pair.Key);
        
        var current = "";
        var decoded = new List&lt;char&gt;();
        
        foreach (char bit in encoded)
        {
            current += bit;
            if (reverseMap.ContainsKey(current))
            {
                decoded.Add(reverseMap[current]);
                current = "";
            }
        }
        
        return new string(decoded.ToArray());
    }
}

public class Program
{
    public static void Main()
    {
        string text = "hello world";
        Console.WriteLine($"Original text: {text}");
        
        var huffman = new HuffmanCoding();
        var (encoded, codes) = huffman.Encode(text);
        
        Console.WriteLine("\nHuffman Codes:");
        foreach (var (c, code) in codes)
        {
            Console.WriteLine($"'{c}': {code}");
        }
        
        Console.WriteLine($"\nEncoded text: {encoded}");
        
        string decoded = huffman.Decode(encoded, codes);
        Console.WriteLine($"Decoded text: {decoded}");
    }
}
                                        </code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>
                </article>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer mt-auto py-4">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-6 text-center text-md-start">
                    <p class="mb-0">&copy; 2024 lVoidi. All rights reserved.</p>
                </div>
                <div class="col-md-6">
                    <ul class="social-links list-inline mb-0 text-center text-md-end">
                        <li class="list-inline-item">
                            <a href="https://github.com/lVoidi" target="_blank" rel="noopener noreferrer" 
                               class="social-link" aria-label="GitHub">
                                <i class="fab fa-github"></i>
                            </a>
                        </li>
                        <li class="list-inline-item">
                            <a href="https://linkedin.com/in/roarba" target="_blank" rel="noopener noreferrer" 
                               class="social-link" aria-label="LinkedIn">
                                <i class="fab fa-linkedin"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="../../static/js/prism.js"></script>
    <script src="../../static/js/huffman-visualization.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const clipboard = new ClipboardJS('.copy-button');
            
            clipboard.on('success', (e) => {
                const button = e.trigger;
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => {
                    button.innerHTML = '<i class="fas fa-copy"></i>';
                }, 2000);
                e.clearSelection();
            });
        });
    </script>
</body>
</html> 