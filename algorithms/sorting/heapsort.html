<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap Sort Algorithm | Efficient Comparison-based Sorting Method</title>

    <!-- SEO Meta Tags -->
    <meta name="description"
        content="Learn the Heap Sort algorithm with O(n log n) time complexity. Includes interactive visualization and implementations in Python, C++, and C# using binary heap data structure.">
    <meta name="keywords"
        content="heap sort, heapsort, binary heap, priority queue, comparison sort, in-place sort, selection sort, computer science, algorithm visualization">
    <meta name="author" content="Rodrigo Arce">
    <meta name="robots" content="index, follow">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://roarba.com/algorithms/sorting/heapsort.html">
    <meta property="og:title" content="Heap Sort Algorithm | Efficient Comparison-based Sorting Method">
    <meta property="og:description"
        content="Learn the Heap Sort algorithm with O(n log n) time complexity. Includes interactive visualization and implementations in Python, C++, and C# using binary heap data structure.">
    <meta property="og:image" content="https://roarba.com/static/img/algorithms/heapsort.jpg">

    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Heap Sort Algorithm | Efficient Comparison-based Sorting Method">
    <meta name="twitter:description"
        content="Learn the Heap Sort algorithm with O(n log n) time complexity. Includes interactive visualization and implementations in Python, C++, and C# using binary heap data structure.">
    <meta name="twitter:image" content="https://roarba.com/static/img/algorithms/heapsort.jpg">

    <!-- Canonical URL -->
    <meta rel="canonical" href="https://roarba.com/algorithms/sorting/heapsort.html">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="../../static/css/style.css" rel="stylesheet">
    <link href="../../static/css/algorithms.css" rel="stylesheet">
    <link href="../../static/css/singularity.css" rel="stylesheet">
    <link href="../../static/css/algorithm-page.css" rel="stylesheet">
    <link href="../../static/css/prism.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <!-- Icon -->
    <link rel="icon" href="../../static/img/icon.png" type="image/x-icon">

    <!-- Schema.org structured data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Heap Sort Algorithm | Efficient Comparison-based Sorting Method",
      "description": "Learn the Heap Sort algorithm with O(n log n) time complexity. Includes interactive visualization and implementations in Python, C++, and C# using binary heap data structure.",
      "image": "https://roarba.com/static/img/algorithms/heapsort.jpg",
      "author": {
        "@type": "Person",
        "name": "lVoidi"
      },
      "publisher": {
        "@type": "Organization",
        "name": "lVoidi Algorithm Portal",
        "logo": {
          "@type": "ImageObject",
          "url": "https://roarba.com/static/img/icon.png"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://roarba.com/algorithms/sorting/heapsort.html"
      },
      "about": {
        "@type": "Thing",
        "name": "Heap Sort Algorithm",
        "description": "A comparison-based sorting algorithm that uses a binary heap data structure to build a max-heap and then repeatedly extracts the maximum element."
      },
      "teaches": "Efficient sorting using heap data structure",
      "educationalUse": "instruction",
      "timeRequired": "PT20M",
      "encodingFormat": "text/html",
      "programmingLanguage": ["Python", "C++", "C#"]
    }
    </script>
</head>

<body>
    <div id="navbar-placeholder"></div>
    <main class="container py-5">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3">
                <div class="algorithm-info-card">
                    <h3>Quick Info</h3>
                    <div class="info-item">
                        <span class="info-label">Category:</span>
                        <span class="info-value">Sorting</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Time Complexity:</span>
                        <span class="info-value">O(n log n)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Space Complexity:</span>
                        <span class="info-value">O(1)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Stable:</span>
                        <span class="info-value">No</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">In-Place:</span>
                        <span class="info-value">Yes</span>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <article class="algorithm-content">
                    <h1>Heap Sort</h1>
                    <div class="algorithm-metadata">
                        <span class="category-tag">Sorting</span>
                        <span class="difficulty-tag">Medium</span>
                    </div>

                    <section class="algorithm-section">
                        <h2>Description</h2>
                        <p>Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It
                            divides its input into a sorted and an unsorted region, and iteratively shrinks the unsorted
                            region by extracting the largest element and moving it to the sorted region.</p>

                        <div class="definition-box">
                            <h4>What is Heap Sort?</h4>
                            <p>Heap Sort works by visualizing the elements of the array as a special kind of complete
                                binary tree called a heap. The algorithm first builds a max heap from the input data,
                                then repeatedly extracts the maximum element from the heap and reconstructs the heap
                                until all elements are sorted.</p>
                        </div>

                        <div class="definition-box">
                            <h4>Key Characteristics</h4>
                            <ul>
                                <li><strong>Comparison-Based:</strong> Elements are sorted by comparing them with each
                                    other</li>
                                <li><strong>In-Place:</strong> Requires only a constant amount of additional memory
                                    space</li>
                                <li><strong>Not Stable:</strong> Does not preserve the relative order of equal elements
                                </li>
                                <li><strong>Non-Adaptive:</strong> Performance doesn't improve on partially sorted data
                                </li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <h4>How Does It Differ from Other Sorting Algorithms?</h4>
                            <p>Unlike Quick Sort, Heap Sort guarantees O(n log n) time complexity in the worst case.
                                Unlike Merge Sort, it doesn't require additional memory space. The algorithm is
                                particularly useful when you need consistent performance and have strict memory
                                constraints.</p>
                        </div>
                    </section>

                    <section class="algorithm-section history-box">
                        <h2>History</h2>
                        <div class="history-content">
                            <img src="../../static/img/williams.jpg" alt="J.W.J. Williams" class="history-image">
                            <p>
                                Heap Sort was invented by J.W.J. Williams in 1964, marking a significant milestone in
                                the history of sorting algorithms. The algorithm was first published in the paper
                                "Algorithm 232 - Heapsort" in the Communications of the ACM.

                                The development of Heap Sort was particularly notable because it was the first sorting
                                algorithm to achieve optimal time complexity O(n log n) in the worst case while using
                                only O(1) auxiliary space. This was a significant improvement over Quick Sort's
                                worst-case time complexity of O(n²).

                                The binary heap data structure, which is fundamental to Heap Sort, was also introduced
                                in this same paper. Robert W. Floyd later improved the algorithm in 1964 with his
                                "bottom-up" heap construction method, which reduced the complexity of building the
                                initial heap from O(n log n) to O(n).
                            </p>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Understanding Heaps</h2>
                        <p>A binary heap is a complete binary tree that forms the foundation of the Heap Sort algorithm.
                            Understanding heaps is crucial to comprehending how Heap Sort achieves its efficiency.</p>

                        <div class="definition-box">
                            <h4>Binary Heap Structure</h4>
                            <p>A binary heap is a complete binary tree with two fundamental properties:</p>
                            <ul>
                                <li><strong>Structure Property:</strong> A binary heap is a complete binary tree, which
                                    means all levels are fully filled except possibly the last level, which is filled
                                    from
                                    left to right. This property ensures the tree remains balanced.</li>
                                <li><strong>Heap Property:</strong> In a max-heap, for any given node I, the value of I
                                    is
                                    greater than or equal to the values of its children. The opposite is true for a
                                    min-heap, where parent nodes are smaller than their children.</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <h4>Array Representation</h4>
                            <p>Binary heaps are typically implemented using arrays, which provides efficient memory
                                usage and access patterns. For an array-based implementation, given an index i:</p>
                            <div class="formula-box">
                                <p>Parent(i) = ⌊(i - 1) / 2⌋</p>
                                <p>LeftChild(i) = 2i + 1</p>
                                <p>RightChild(i) = 2i + 2</p>
                            </div>
                            <p>This mathematical relationship allows us to navigate the tree structure without storing
                                explicit pointers, making heap operations very efficient.</p>
                        </div>

                        <div class="definition-box">
                            <h4>Max-Heap vs Min-Heap</h4>
                            <p><strong>Max-Heap:</strong> The parent node is always greater than or equal to its
                                children. The maximum element is always at the root. This is what Heap Sort uses for
                                ascending order sorting.</p>
                            <p><strong>Min-Heap:</strong> The parent node is always less than or equal to its children.
                                The minimum element is always at the root. This can be used for descending order
                                sorting.</p>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>How It Works</h2>
                        <p>Heap Sort operates in two main phases: building the heap and extracting elements in sorted
                            order.</p>

                        <div class="definition-box">
                            <h4>Phase 1: Build Max Heap</h4>
                            <p>The first step is to convert the input array into a max heap structure. This is done by
                                calling the heapify operation on all non-leaf nodes, starting from the last non-leaf
                                node and moving up to the root.</p>
                            <p>The last non-leaf node is at index ⌊n/2⌋ - 1, where n is the array length. We work
                                backwards because heapifying assumes the children are already valid heaps.</p>
                            <p><strong>Time Complexity:</strong> Although it appears to be O(n log n), building a heap
                                from an unsorted array actually takes O(n) time due to the mathematical properties of
                                the heap structure.</p>
                        </div>

                        <div class="definition-box">
                            <h4>Phase 2: Heapify Operation</h4>
                            <p>Heapify is the core operation that maintains the heap property. When called on a node,
                                it:</p>
                            <ul>
                                <li>Compares the node with its left and right children</li>
                                <li>Identifies the largest element among the three</li>
                                <li>If the largest is not the current node, swaps them</li>
                                <li>Recursively calls heapify on the affected child subtree</li>
                            </ul>
                            <p>This process continues down the tree until the heap property is satisfied or a leaf node
                                is reached.</p>
                        </div>

                        <div class="definition-box">
                            <h4>Phase 3: Extract and Sort</h4>
                            <p>Once the max heap is built, we repeatedly perform the following steps:</p>
                            <ol>
                                <li><strong>Swap:</strong> Exchange the root (maximum element) with the last element in
                                    the unsorted portion of the array. This moves the maximum element to its correct
                                    sorted position.</li>
                                <li><strong>Reduce Heap Size:</strong> Decrease the heap size by 1, effectively removing
                                    the sorted element from consideration.</li>
                                <li><strong>Heapify Root:</strong> Call heapify on the root to restore the heap
                                    property, as the swap may have violated it.</li>
                                <li><strong>Repeat:</strong> Continue this process until the heap contains only one
                                    element.</li>
                            </ol>
                            <p>After n-1 iterations, all elements will be in sorted order. The array is sorted in-place,
                                with the maximum elements gradually accumulating at the end.</p>
                        </div>

                        <div class="definition-box">
                            <h4>Step-by-Step Example</h4>
                            <p>Consider sorting [4, 10, 3, 5, 1]:</p>
                            <ol>
                                <li><strong>Build Max Heap:</strong> [10, 5, 3, 4, 1] - The array is rearranged into a
                                    max heap</li>
                                <li><strong>First Extraction:</strong> Swap 10 and 1, then heapify: [5, 4, 3, 1 | 10]
                                </li>
                                <li><strong>Second Extraction:</strong> Swap 5 and 1, then heapify: [4, 1, 3 | 5, 10]
                                </li>
                                <li><strong>Third Extraction:</strong> Swap 4 and 3, then heapify: [3, 1 | 4, 5, 10]
                                </li>
                                <li><strong>Fourth Extraction:</strong> Swap 3 and 1: [1 | 3, 4, 5, 10]</li>
                                <li><strong>Result:</strong> [1, 3, 4, 5, 10] - Fully sorted array</li>
                            </ol>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Visualization</h2>
                        <div class="visualization-container">
                            <div class="visualization-controls">
                                <button class="btn btn-primary" id="startVisualization">
                                    <i class="fas fa-play"></i> Start
                                </button>
                                <button class="btn btn-secondary" id="resetVisualization">
                                    <i class="fas fa-redo"></i> Reset
                                </button>
                                <div class="speed-control">
                                    <label>Speed:</label>
                                    <input type="range" id="speedControl" min="1" max="5" value="3">
                                </div>
                            </div>
                            <div class="visualization-area">
                                <svg id="heapSortVisualization" width="100%" height="300"></svg>
                            </div>
                            <div class="visualization-steps">
                                <p id="currentStep">Click Start to begin visualization</p>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Implementation</h2>
                        <div class="implementation-tabs">
                            <ul class="nav nav-tabs" role="tablist">
                                <li class="nav-item">
                                    <a class="nav-link active" data-bs-toggle="tab" href="#python">Python</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#cpp">C++</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#csharp">C#</a>
                                </li>
                            </ul>
                            <div class="tab-content">
                                <div class="tab-pane fade show active" id="python">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#python-code">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-python" id="python-code">
class HeapSort:
    @staticmethod
    def heapify(arr, n, i):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2

        # Compare with left child
        if left < n and arr[left] > arr[largest]:
            largest = left

        # Compare with right child
        if right < n and arr[right] > arr[largest]:
            largest = right

        # If largest is not root
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            HeapSort.heapify(arr, n, largest)

    @staticmethod
    def sort(arr):
        n = len(arr)

        # Build max heap
        for i in range(n // 2 - 1, -1, -1):
            HeapSort.heapify(arr, n, i)

        # Extract elements from heap one by one
        for i in range(n - 1, 0, -1):
            arr[0], arr[i] = arr[i], arr[0]
            HeapSort.heapify(arr, i, 0)

        return arr

# Example usage
if __name__ == "__main__":
    arr = [64, 34, 25, 12, 22, 11, 90]
    print("Original array:", arr)
    HeapSort.sort(arr)
    print("Sorted array:", arr)
                                        </code></pre>
                                    </div>
                                </div>

                                <div class="tab-pane fade" id="cpp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#cpp-code">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-cpp" id="cpp-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;

class HeapSort {
private:
    static void heapify(std::vector&lt;int&gt;& arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && arr[left] > arr[largest])
            largest = left;

        if (right < n && arr[right] > arr[largest])
            largest = right;

        if (largest != i) {
            std::swap(arr[i], arr[largest]);
            heapify(arr, n, largest);
        }
    }

public:
    static void sort(std::vector&lt;int&gt;& arr) {
        int n = arr.size();

        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // Extract elements from heap one by one
        for (int i = n - 1; i > 0; i--) {
            std::swap(arr[0], arr[i]);
            heapify(arr, i, 0);
        }
    }
};

// Example usage
int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    
    std::cout << "Original array: ";
    for (int num : arr) std::cout << num << " ";
    std::cout << std::endl;
    
    HeapSort::sort(arr);
    
    std::cout << "Sorted array: ";
    for (int num : arr) std::cout << num << " ";
    std::cout << std::endl;
    
    return 0;
}
                                        </code></pre>
                                    </div>
                                </div>

                                <div class="tab-pane fade" id="csharp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#csharp-code">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-csharp" id="csharp-code">
public class HeapSort
{
    private static void Heapify(int[] arr, int n, int i)
    {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && arr[left] > arr[largest])
            largest = left;

        if (right < n && arr[right] > arr[largest])
            largest = right;

        if (largest != i)
        {
            (arr[i], arr[largest]) = (arr[largest], arr[i]);
            Heapify(arr, n, largest);
        }
    }

    public static void Sort(int[] arr)
    {
        int n = arr.Length;

        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--)
            Heapify(arr, n, i);

        // Extract elements from heap one by one
        for (int i = n - 1; i > 0; i--)
        {
            (arr[0], arr[i]) = (arr[i], arr[0]);
            Heapify(arr, i, 0);
        }
    }

    // Example usage
    public static void Main()
    {
        int[] arr = { 64, 34, 25, 12, 22, 11, 90 };
        
        Console.WriteLine("Original array: " + string.Join(" ", arr));
        Sort(arr);
        Console.WriteLine("Sorted array: " + string.Join(" ", arr));
    }
}
                                        </code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Complexity Analysis</h2>
                        <table class="complexity-table">
                            <tr>
                                <th>Operation</th>
                                <th>Time Complexity</th>
                            </tr>
                            <tr>
                                <td>Build Heap</td>
                                <td>O(n)</td>
                            </tr>
                            <tr>
                                <td>Heapify</td>
                                <td>O(log n)</td>
                            </tr>
                            <tr>
                                <td>Overall Sorting</td>
                                <td>O(n log n)</td>
                            </tr>
                        </table>
                    </section>

                    <section class="algorithm-section">
                        <h2>Advantages and Disadvantages</h2>
                        <div class="pros-cons">
                            <div class="pros">
                                <h3>Advantages</h3>
                                <ul>
                                    <li>Guaranteed O(n log n) time complexity</li>
                                    <li>In-place sorting algorithm</li>
                                    <li>No extra space required</li>
                                    <li>Great for partially sorted arrays</li>
                                </ul>
                            </div>
                            <div class="cons">
                                <h3>Disadvantages</h3>
                                <ul>
                                    <li>Not stable sort</li>
                                    <li>Poor cache performance</li>
                                    <li>Generally slower than quicksort</li>
                                    <li>Not adaptive</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </article>
            </div>
        </div>
    </main>

    <div id="footer-placeholder"></div>
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script src="../../static/js/prism.js"></script>
    <script src="../../static/js/heapsort-visualization.js"></script>
    <script>
        // Initialize clipboard.js
        document.addEventListener('DOMContentLoaded', () => {
            const clipboard = new ClipboardJS('.copy-button');

            clipboard.on('success', (e) => {
                const button = e.trigger;
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => {
                    button.innerHTML = '<i class="fas fa-copy"></i>';
                }, 2000);
                e.clearSelection();
            });
        });
    </script>
    <script src="../../static/js/templates.js"></script>
</body>

</html>