<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Selection Sort Algorithm | Simple In-Place Sorting Method</title>

  <!-- SEO Meta Tags -->
  <meta name="description"
    content="Learn the Selection Sort algorithm with O(n²) time complexity. Includes interactive visualization and implementations in Python, C++, and C#, minimizing the number of swaps." />
  <meta name="keywords"
    content="selection sort, in-place sort, comparison sort, quadratic time sort, minimal swaps, computer science, algorithm visualization" />
  <meta name="author" content="Rodrigo Arce" />
  <meta name="robots" content="index, follow" />

  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://roarba.com/algorithms/sorting/selectionsort.html" />
  <meta property="og:title" content="Selection Sort Algorithm | Simple In-Place Sorting Method" />
  <meta property="og:description"
    content="Learn the Selection Sort algorithm with O(n²) time complexity. Includes interactive visualization and implementations in Python, C++, and C#, minimizing the number of swaps." />
  <meta property="og:image" content="https://roarba.com/static/img/algorithms/selectionsort.jpg" />

  <!-- Twitter Card Tags -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Selection Sort Algorithm | Simple In-Place Sorting Method" />
  <meta name="twitter:description"
    content="Learn the Selection Sort algorithm with O(n²) time complexity. Includes interactive visualization and implementations in Python, C++, and C#, minimizing the number of swaps." />
  <meta name="twitter:image" content="https://roarba.com/static/img/algorithms/selectionsort.jpg" />

  <!-- Canonical URL -->
  <meta rel="canonical" href="https://roarba.com/algorithms/sorting/selectionsort.html" />

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="../../static/css/style.css" rel="stylesheet" />
  <link href="../../static/css/algorithms.css" rel="stylesheet" />
  <link href="../../static/css/singularity.css" rel="stylesheet">
  <link href="../../static/css/algorithm-page.css" rel="stylesheet" />
  <link href="../../static/css/prism.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet" />
  <link rel="icon" href="../../static/img/icon.png" type="image/x-icon" />

  <!-- Schema.org structured data -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Selection Sort Algorithm | Simple In-Place Sorting Method",
      "description": "Learn the Selection Sort algorithm with O(n²) time complexity. Includes interactive visualization and implementations in Python, C++, and C#, minimizing the number of swaps.",
      "image": "https://roarba.com/static/img/algorithms/selectionsort.jpg",
      "author": {
        "@type": "Person",
        "name": "lVoidi"
      },
      "publisher": {
        "@type": "Organization",
        "name": "lVoidi Algorithm Portal",
        "logo": {
          "@type": "ImageObject",
          "url": "https://roarba.com/static/img/icon.png"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://roarba.com/algorithms/sorting/selectionsort.html"
      },
      "about": {
        "@type": "Thing",
        "name": "Selection Sort Algorithm",
        "description": "A simple comparison-based sorting algorithm that divides the input into a sorted and an unsorted region, repeatedly selecting the smallest element from the unsorted region."
      },
      "teaches": "Simple sorting with minimal swaps",
      "educationalUse": "instruction",
      "timeRequired": "PT15M",
      "encodingFormat": "text/html",
      "programmingLanguage": ["Python", "C++", "C#"]
    }
    </script>
</head>

<body>
  <!-- Navbar -->
  <div id="navbar-placeholder"></div>

  <!-- Algorithm Content -->
  <main class="container py-5">
    <div class="row">
      <!-- Sidebar with Quick Info -->
      <div class="col-md-3">
        <div class="algorithm-info-card">
          <h3>Quick Info</h3>
          <div class="info-item">
            <span class="info-label">Category:</span>
            <span class="info-value">Sorting</span>
          </div>
          <div class="info-item">
            <span class="info-label">Time Complexity:</span>
            <span class="info-value">O(n²)</span>
          </div>
          <div class="info-item">
            <span class="info-label">Space Complexity:</span>
            <span class="info-value">O(1)</span>
          </div>
          <div class="info-item">
            <span class="info-label">Stable:</span>
            <span class="info-value">No</span>
          </div>
          <div class="info-item">
            <span class="info-label">In-Place:</span>
            <span class="info-value">Yes</span>
          </div>
        </div>
      </div>

      <!-- Main Content -->
      <div class="col-md-9">
        <article class="algorithm-content">
          <h1>Selection Sort</h1>
          <div class="algorithm-metadata">
            <span class="category-tag">Sorting</span>
            <span class="difficulty-tag">Easy</span>
          </div>

          <section class="algorithm-section">
            <h2>Description</h2>
            <p>
              Selection Sort is a straightforward comparison-based sorting algorithm that operates on a simple yet
              effective principle:
              repeatedly selecting the smallest (or largest, depending on sorting order) element from the unsorted
              portion of the array
              and moving it to its correct position in the sorted portion. Despite its simplicity, understanding its
              mechanics provides
              valuable insight into fundamental sorting concepts.
            </p>
            <p>
              The algorithm divides the input array into two conceptual regions: a sorted subarray that builds up from
              left to right,
              and an unsorted subarray that shrinks as the algorithm progresses. Initially, the sorted subarray is
              empty, and the entire
              array is considered unsorted. During each iteration, Selection Sort scans through the unsorted region to
              find the minimum
              element, then swaps it with the first element of the unsorted region. This process effectively expands the
              sorted region
              by one element while contracting the unsorted region by the same amount.
            </p>
            <p>
              What distinguishes Selection Sort from other quadratic sorting algorithms is its consistency and minimal
              write operations.
              Unlike Bubble Sort, which may perform many swaps, Selection Sort performs exactly <strong>n-1
                swaps</strong> for an array
              of n elements—one swap per iteration (except when the minimum element is already in the correct position).
              This makes it
              particularly useful when write operations are significantly more expensive than read operations, such as
              when working with
              flash memory or EEPROM storage.
            </p>
            <p>
              However, this algorithm has a critical limitation: it always performs O(n²) comparisons regardless of the
              initial ordering
              of the data. Whether the array is already sorted, reverse sorted, or randomly arranged, Selection Sort
              will examine every
              element in the unsorted portion during each iteration. This lack of adaptability means it cannot take
              advantage of any
              existing order in the data, making it inefficient for large datasets or scenarios where the input might be
              partially sorted.
            </p>
            <p>
              Another important characteristic is that Selection Sort is <strong>not stable</strong>. A stable sorting
              algorithm preserves
              the relative order of elements with equal values. Because Selection Sort swaps elements across potentially
              large distances
              in the array, it can inadvertently change the relative positions of equal elements, which may be
              undesirable when sorting
              complex objects by one of multiple fields.
            </p>
          </section>

          <section class="algorithm-section">
            <h2>How It Works</h2>
            <p>
              Selection Sort operates through a systematic process of partitioning the array into two conceptual regions
              and progressively building the sorted output. Understanding each step of this process is crucial to
              grasping
              how the algorithm achieves its sorting objective.
            </p>

            <div class="how-it-works-steps">
              <div class="step-item">
                <div class="step-number">1</div>
                <div class="step-content">
                  <h4>Initialize the Array Partitions</h4>
                  <p>
                    The algorithm begins by conceptually dividing the array into two regions: a sorted portion
                    (initially empty)
                    on the left and an unsorted portion (initially the entire array) on the right. The boundary between
                    these
                    regions starts at the beginning of the array and moves rightward with each iteration.
                  </p>
                </div>
              </div>

              <div class="step-item">
                <div class="step-number">2</div>
                <div class="step-content">
                  <h4>Find the Minimum Element</h4>
                  <p>
                    In each iteration, the algorithm scans through the entire unsorted portion to locate the minimum
                    element.
                    This is done by maintaining a variable that tracks the index of the smallest element found so far.
                    The
                    algorithm compares each element in the unsorted region with the current minimum, updating the
                    minimum
                    index whenever a smaller element is discovered. This linear search through the unsorted portion is
                    what
                    contributes to the algorithm's O(n²) time complexity.
                  </p>
                </div>
              </div>

              <div class="step-item">
                <div class="step-number">3</div>
                <div class="step-content">
                  <h4>Swap to the Correct Position</h4>
                  <p>
                    Once the minimum element is identified, it is swapped with the first element of the unsorted portion
                    (which is the element immediately after the sorted portion). This single swap operation places the
                    minimum element in its final, correct position. Note that if the minimum element is already at the
                    first position of the unsorted region, no swap is necessary, though the algorithm still counts this
                    as an iteration.
                  </p>
                </div>
              </div>

              <div class="step-item">
                <div class="step-number">4</div>
                <div class="step-content">
                  <h4>Expand the Sorted Region</h4>
                  <p>
                    After the swap, the boundary between the sorted and unsorted portions advances one position to the
                    right. The element that was just placed is now considered part of the sorted region and will never
                    be examined again. This means the sorted portion grows by one element while the unsorted portion
                    shrinks by one element with each iteration.
                  </p>
                </div>
              </div>

              <div class="step-item">
                <div class="step-number">5</div>
                <div class="step-content">
                  <h4>Repeat Until Completion</h4>
                  <p>
                    Steps 2 through 4 are repeated until the unsorted portion contains only one element (or is empty).
                    At this point, the last remaining element must be in its correct position, as all smaller elements
                    have already been placed in the sorted portion. The algorithm requires exactly <strong>n-1
                      passes</strong>
                    for an array of n elements, since the last element is automatically in place when n-1 elements have
                    been sorted.
                  </p>
                </div>
              </div>
            </div>

            <div class="algorithm-example">
              <h4>Step-by-Step Example</h4>
              <p>Consider sorting the array <code>[64, 25, 12, 22, 11]</code>:</p>
              <ul class="example-steps">
                <li><strong>Initial:</strong> <code>[64, 25, 12, 22, 11]</code> - Entire array is unsorted</li>
                <li><strong>Pass 1:</strong> Find minimum (11), swap with first → <code>[11, 25, 12, 22, 64]</code></li>
                <li><strong>Pass 2:</strong> Find minimum (12), swap with first unsorted →
                  <code>[11, 12, 25, 22, 64]</code>
                </li>
                <li><strong>Pass 3:</strong> Find minimum (22), swap with first unsorted →
                  <code>[11, 12, 22, 25, 64]</code>
                </li>
                <li><strong>Pass 4:</strong> Find minimum (25), already in position → <code>[11, 12, 22, 25, 64]</code>
                </li>
                <li><strong>Complete:</strong> Last element (64) is automatically in place</li>
              </ul>
              <p class="example-note">
                Notice how each pass guarantees one more element is in its final sorted position, building the solution
                incrementally from left to right.
              </p>
            </div>
          </section>
          </p>

          <section class="algorithm-section">
            <h2>Visualization</h2>
            <div class="visualization-container">
              <div class="visualization-controls">
                <button class="btn btn-primary" id="startVisualization">
                  <i class="fas fa-play"></i> Start
                </button>
                <button class="btn btn-secondary" id="resetVisualization">
                  <i class="fas fa-redo"></i> Reset
                </button>
                <div class="speed-control">
                  <label>Speed:</label>
                  <input type="range" id="speedControl" min="1" max="5" value="3" />
                </div>
              </div>
              <div class="visualization-area">
                <svg id="selectionSortVisualization" width="100%" height="300"></svg>
              </div>
              <div class="visualization-steps">
                <p id="currentStep">Click Start to begin visualization</p>
              </div>
            </div>
          </section>

          <section class="algorithm-section">
            <h2>Implementation</h2>
            <div class="implementation-tabs">
              <ul class="nav nav-tabs" role="tablist">
                <li class="nav-item">
                  <a class="nav-link active" data-bs-toggle="tab" href="#python">Python</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" data-bs-toggle="tab" href="#cpp">C++</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" data-bs-toggle="tab" href="#csharp">C#</a>
                </li>
              </ul>
              <div class="tab-content">
                <div class="tab-pane fade show active" id="python">
                  <div class="code-wrapper">
                    <button class="copy-button" data-clipboard-target="#python-code">
                      <i class="fas fa-copy"></i>
                    </button>
                    <pre><code class="language-python" id="python-code">
def selection_sort(arr):
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
                
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Usage example
if __name__ == "__main__":
    arr = [64, 34, 25, 12, 22, 11, 90]
    print("Original array:", arr)
    selection_sort(arr)
    print("Sorted array:", arr)
                      </code></pre>
                  </div>
                </div>

                <div class="tab-pane fade" id="cpp">
                  <div class="code-wrapper">
                    <button class="copy-button" data-clipboard-target="#cpp-code">
                      <i class="fas fa-copy"></i>
                    </button>
                    <pre><code class="language-cpp" id="cpp-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;

class SelectionSort {
public:
    static void sort(std::vector&lt;int&gt;& arr) {
        int n = arr.size();
        
        // One by one move boundary of unsorted subarray
        for (int i = 0; i < n - 1; i++) {
            // Find the minimum element in unsorted array
            int min_idx = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[min_idx]) {
                    min_idx = j;
                }
            }
            
            // Swap the found minimum element with the first element
            if (min_idx != i) {
                std::swap(arr[min_idx], arr[i]);
            }
        }
    }
};

// Usage example
int main() {
    std::vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    
    std::cout << "Original array: ";
    for (int num : arr) std::cout << num << " ";
    std::cout << std::endl;
    
    SelectionSort::sort(arr);
    
    std::cout << "Sorted array: ";
    for (int num : arr) std::cout << num << " ";
    std::cout << std::endl;
    
    return 0;
}
                      </code></pre>
                  </div>
                </div>

                <div class="tab-pane fade" id="csharp">
                  <div class="code-wrapper">
                    <button class="copy-button" data-clipboard-target="#csharp-code">
                      <i class="fas fa-copy"></i>
                    </button>
                    <pre><code class="language-csharp" id="csharp-code">
public class SelectionSort
{
    public static void Sort(int[] arr)
    {
        int n = arr.Length;
        
        // One by one move boundary of unsorted subarray
        for (int i = 0; i < n - 1; i++)
        {
            // Find the minimum element in unsorted array
            int min_idx = i;
            for (int j = i + 1; j < n; j++)
            {
                if (arr[j] < arr[min_idx])
                {
                    min_idx = j;
                }
            }
            
            // Swap the found minimum element with the first element
            if (min_idx != i)
            {
                (arr[min_idx], arr[i]) = (arr[i], arr[min_idx]);
            }
        }
    }
    
    // Usage example
    public static void Main(string[] args)
    {
        int[] arr = { 64, 34, 25, 12, 22, 11, 90 };
        
        Console.WriteLine("Original array: " + string.Join(" ", arr));
        Sort(arr);
        Console.WriteLine("Sorted array: " + string.Join(" ", arr));
    }
}
                      </code></pre>
                  </div>
                </div>
              </div>
            </div>
          </section>

          <section class="algorithm-section">
            <h2>Complexity Analysis</h2>
            <table class="complexity-table">
              <tr>
                <th>Case</th>
                <th>Time Complexity</th>
              </tr>
              <tr>
                <td>Best</td>
                <td>O(n²)</td>
              </tr>
              <tr>
                <td>Average</td>
                <td>O(n²)</td>
              </tr>
              <tr>
                <td>Worst</td>
                <td>O(n²)</td>
              </tr>
            </table>
          </section>

          <section class="algorithm-section">
            <h2>Advantages and Disadvantages</h2>
            <div class="pros-cons">
              <div class="pros">
                <h3>Advantages</h3>
                <ul>
                  <li>Simple and easy to understand</li>
                  <li>Performs well on small arrays</li>
                  <li>In-place algorithm - requires no extra space</li>
                  <li>Minimal number of swaps (O(n) swaps)</li>
                </ul>
              </div>
              <div class="cons">
                <h3>Disadvantages</h3>
                <ul>
                  <li>O(n²) complexity makes it inefficient for large lists</li>
                  <li>Not stable - does not preserve the relative order of equal elements</li>
                  <li>Does not adapt to the data in any way</li>
                </ul>
              </div>
            </div>
          </section>
        </article>
      </div>
    </div>
  </main>

  <div id="footer-placeholder"></div>
  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="../../static/js/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    const clipboard = new ClipboardJS(".copy-button");
    clipboard.on("success", function (e) {
      const button = e.trigger;
      button.innerHTML = '<i class="fas fa-check"></i>';
      setTimeout(() => {
        button.innerHTML = '<i class="fas fa-copy"></i>';
      }, 2000);
    });
  </script>
  <script src="../../static/js/selection-sort-visualization.js"></script>
  <script src="../../static/js/templates.js"></script>
</body>

</html>