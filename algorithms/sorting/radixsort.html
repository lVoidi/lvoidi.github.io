<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radix Sort Algorithm | Non-comparative Digit-based Sorting Method</title>

    <!-- SEO Meta Tags -->
    <meta name="description"
        content="Learn the Radix Sort algorithm with O(nk) time complexity. Includes interactive visualization and implementations in Python, C++, and C# for efficiently sorting integers by their digits.">
    <meta name="keywords"
        content="radix sort, digital sort, LSD sort, MSD sort, non-comparative sort, linear time sorting, numerical sorting, computer science, algorithm visualization">
    <meta name="author" content="lVoidi">
    <meta name="robots" content="index, follow">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://roarba.com/algorithms/sorting/radixsort.html">
    <meta property="og:title" content="Radix Sort Algorithm | Non-comparative Digit-based Sorting Method">
    <meta property="og:description"
        content="Learn the Radix Sort algorithm with O(nk) time complexity. Includes interactive visualization and implementations in Python, C++, and C# for efficiently sorting integers by their digits.">
    <meta property="og:image" content="https://roarba.com/static/img/algorithms/radixsort.jpg">

    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Radix Sort Algorithm | Non-comparative Digit-based Sorting Method">
    <meta name="twitter:description"
        content="Learn the Radix Sort algorithm with O(nk) time complexity. Includes interactive visualization and implementations in Python, C++, and C# for efficiently sorting integers by their digits.">
    <meta name="twitter:image" content="https://roarba.com/static/img/algorithms/radixsort.jpg">

    <!-- Canonical URL -->
    <meta rel="canonical" href="https://roarba.com/algorithms/sorting/radixsort.html">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="../../static/css/style.css" rel="stylesheet">
    <link href="../../static/css/singularity.css" rel="stylesheet">
    <link href="../../static/css/algorithms.css" rel="stylesheet">
    <link href="../../static/css/algorithm-page.css" rel="stylesheet">
    <link href="../../static/css/prism.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <!-- Icon -->
    <link rel="icon" href="../../static/img/icon.png" type="image/x-icon">

    <!-- Schema.org structured data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Radix Sort Algorithm | Non-comparative Digit-based Sorting Method",
      "description": "Learn the Radix Sort algorithm with O(nk) time complexity. Includes interactive visualization and implementations in Python, C++, and C# for efficiently sorting integers by their digits.",
      "image": "https://roarba.com/static/img/algorithms/radixsort.jpg",
      "author": {
        "@type": "Person",
        "name": "lVoidi"
      },
      "publisher": {
        "@type": "Organization",
        "name": "lVoidi Algorithm Portal",
        "logo": {
          "@type": "ImageObject",
          "url": "https://roarba.com/static/img/icon.png"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://roarba.com/algorithms/sorting/radixsort.html"
      },
      "about": {
        "@type": "Thing",
        "name": "Radix Sort Algorithm",
        "description": "A non-comparative sorting algorithm that processes integer digits position by position, starting from the least significant digit to the most significant."
      },
      "teaches": "Linear time sorting using digit-by-digit processing",
      "educationalUse": "instruction",
      "timeRequired": "PT20M",
      "encodingFormat": "text/html",
      "programmingLanguage": ["Python", "C++", "C#"]
    }
    </script>
</head>

<body>
    <!-- Navbar -->
    <div id="navbar-placeholder"></div>

    <main class="container py-5">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3">
                <div class="algorithm-info-card">
                    <h3>Quick Info</h3>
                    <div class="info-item">
                        <span class="info-label">Category:</span>
                        <span class="info-value">Sorting</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Time Complexity:</span>
                        <span class="info-value">O(d * (n + k))</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Space Complexity:</span>
                        <span class="info-value">O(n + k)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Stable:</span>
                        <span class="info-value">Yes</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">In-Place:</span>
                        <span class="info-value">No</span>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <article class="algorithm-content">
                    <h1>Radix Sort</h1>
                    <div class="algorithm-metadata">
                        <span class="category-tag">Sorting</span>
                        <span class="difficulty-tag">Medium</span>
                    </div>

                    <section class="algorithm-section">
                        <h2>Description</h2>
                        <p>Radix Sort is a non-comparative integer sorting algorithm that sorts data with integer keys
                            by grouping the keys by individual digits that share the same significant position and
                            value. Unlike comparison-based sorting algorithms (such as Quick Sort or Merge Sort), Radix
                            Sort processes data digit by digit, making it particularly efficient for sorting integers or
                            strings of fixed length.</p>

                        <p>The algorithm works by distributing elements into buckets according to their radix (base).
                            For decimal numbers, it uses base 10, creating 10 buckets (0-9). The key insight is that by
                            sorting numbers digit by digit, starting from the least significant digit (rightmost) to the
                            most significant digit (leftmost), we can achieve a fully sorted array without ever
                            comparing two complete numbers directly.</p>

                        <p>Radix Sort typically uses Counting Sort as a subroutine because Counting Sort is stable
                            (preserves the relative order of equal elements) and efficient for small range of values.
                            This stability is crucial for Radix Sort to work correctly, as it ensures that the sorting
                            done in previous digit positions is maintained when sorting subsequent positions.</p>

                        <p>The algorithm's time complexity of O(d * (n + k)) makes it extremely efficient when the
                            number of digits (d) is small relative to the number of elements (n). For example, sorting a
                            million 32-bit integers can be done in linear time, making Radix Sort one of the fastest
                            sorting algorithms for specific use cases.</p>
                    </section>

                    <section class="algorithm-section history-box">
                        <h2>History</h2>
                        <div class="history-content">
                            <img src="../../static/img/radix-sort.jpg" alt="Radix Sort History" class="history-image">
                            <p>
                                Radix Sort's origins can be traced back to the early days of mechanical data processing.
                                It was first used with punch card sorting machines in the 1880s by Herman Hollerith. The
                                method was particularly important during the early computer era when sorting large
                                volumes of punch card data was a common task.

                                The algorithm gained prominence in computer science during the 1950s and 1960s with the
                                advent of digital computers. It was particularly useful for sorting fixed-length records
                                with multiple sort keys, such as dates or social security numbers.

                                The term "radix" refers to the base of the number system being used (typically base 10
                                for decimal numbers or base 2 for binary numbers). The algorithm's efficiency in sorting
                                integers and fixed-length strings has made it a fundamental part of many large-scale
                                sorting applications.
                            </p>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>How It Works</h2>
                        <p>Radix Sort processes numbers by examining one digit position at a time, from the least
                            significant digit (LSD) to the most significant digit (MSD). Here's a detailed breakdown of
                            the process:</p>

                        <ol>
                            <li><strong>Initialization and Digit Identification:</strong>
                                <ul>
                                    <li>First, find the maximum number in the array to determine how many digits we need
                                        to process</li>
                                    <li>For example, if the maximum number is 802, we need to process 3 digit positions
                                        (ones, tens, hundreds)</li>
                                    <li>Initialize a variable (typically called 'exp' for exponent) to 1, representing
                                        the current digit position being sorted</li>
                                </ul>
                            </li>

                            <li><strong>Processing Each Digit Position (Starting from Rightmost):</strong>
                                <ul>
                                    <li>For the current digit position, perform a stable sort (usually Counting Sort) on
                                        all numbers based on that digit only</li>
                                    <li>Extract the digit at the current position using the formula: (number / exp) % 10
                                    </li>
                                    <li>For example, in number 170 with exp=10 (tens place): (170/10) % 10 = 7</li>
                                    <li>Create 10 buckets (indexed 0-9) to hold numbers based on their current digit
                                        value</li>
                                </ul>
                            </li>

                            <li><strong>Counting Sort Subroutine for Current Digit:</strong>
                                <ul>
                                    <li><strong>Step 1 - Count:</strong> Count how many numbers have each digit (0-9) at
                                        the current position. Store counts in a count array of size 10</li>
                                    <li><strong>Step 2 - Cumulative Count:</strong> Transform the count array so each
                                        position contains the cumulative count. This tells us the ending position of
                                        each digit group in the output</li>
                                    <li><strong>Step 3 - Build Output:</strong> Traverse the input array from right to
                                        left, placing each number in its correct position in the output array based on
                                        its current digit and the count array</li>
                                    <li><strong>Step 4 - Copy Back:</strong> Copy the sorted output array back to the
                                        original array</li>
                                </ul>
                            </li>

                            <li><strong>Move to Next Digit Position:</strong>
                                <ul>
                                    <li>Multiply the exp variable by 10 to move to the next digit position (ones → tens
                                        → hundreds, etc.)</li>
                                    <li>Repeat the counting sort process for this new digit position</li>
                                    <li>The stability of counting sort ensures that the relative order established by
                                        previous digit positions is preserved</li>
                                </ul>
                            </li>

                            <li><strong>Completion:</strong>
                                <ul>
                                    <li>Continue processing digit positions until exp becomes greater than the maximum
                                        number</li>
                                    <li>After processing all digit positions from least significant to most significant,
                                        the array is completely sorted</li>
                                    <li>The algorithm terminates with a fully sorted array in ascending order</li>
                                </ul>
                            </li>
                        </ol>

                        <div class="example-box definition-box">
                            <h4>Example Walkthrough:</h4>
                            <p><strong>Input:</strong> [170, 45, 75, 90, 802, 24, 2, 66]</p>
                            <p><strong>Pass 1 (ones place):</strong> Sort by last digit → [170, 90, 802, 2, 24, 45, 75,
                                66]</p>
                            <p><strong>Pass 2 (tens place):</strong> Sort by second digit → [802, 2, 24, 45, 66, 170,
                                75, 90]</p>
                            <p><strong>Pass 3 (hundreds place):</strong> Sort by first digit → [2, 24, 45, 66, 75, 90,
                                170, 802]</p>
                            <p><strong>Output:</strong> [2, 24, 45, 66, 75, 90, 170, 802] ✓ Sorted!</p>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Visualization</h2>
                        <div class="visualization-container">
                            <div class="visualization-controls">
                                <button class="btn btn-primary" id="startVisualization">
                                    <i class="fas fa-play"></i> Start
                                </button>
                                <button class="btn btn-secondary" id="resetVisualization">
                                    <i class="fas fa-redo"></i> Reset
                                </button>
                                <div class="speed-control">
                                    <label>Speed:</label>
                                    <input type="range" id="speedControl" min="1" max="5" value="3">
                                </div>
                            </div>
                            <div class="visualization-area">
                                <svg id="radixSortVisualization" width="100%" height="400"></svg>
                            </div>
                            <div class="visualization-steps">
                                <p id="currentStep">Click Start to begin visualization</p>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Implementation</h2>
                        <div class="implementation-tabs">
                            <ul class="nav nav-tabs" role="tablist">
                                <li class="nav-item">
                                    <a class="nav-link active" data-bs-toggle="tab" href="#python">Python</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#cpp">C++</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#csharp">C#</a>
                                </li>
                            </ul>
                            <div class="tab-content">
                                <!-- Python Implementation -->
                                <div class="tab-pane fade show active" id="python">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#python-code">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-python" id="python-code">
def counting_sort_by_digit(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10
    
    # Store count of occurrences in count[]
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1
    
    # Change count[i] so that count[i] contains actual
    # position of this digit in output[]
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    # Build the output array
    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1
    
    # Copy the output array to arr[]
    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    # Find the maximum number to know number of digits
    max_num = max(arr)
    
    # Do counting sort for every digit
    exp = 1
    while max_num // exp > 0:
        counting_sort_by_digit(arr, exp)
        exp *= 10
    
    return arr

# Example usage
if __name__ == "__main__":
    arr = [170, 45, 75, 90, 802, 24, 2, 66]
    print("Original array:", arr)
    radix_sort(arr)
    print("Sorted array:", arr)
                                        </code></pre>
                                    </div>
                                </div>

                                <!-- C++ Implementation -->
                                <div class="tab-pane fade" id="cpp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#cpp-code">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-cpp" id="cpp-code">
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

void countingSortByDigit(std::vector&lt;int&gt;& arr, int exp) {
    int n = arr.size();
    std::vector&lt;int&gt; output(n);
    std::vector&lt;int&gt; count(10, 0);
    
    // Store count of occurrences in count[]
    for(int i = 0; i < n; i++)
        count[(arr[i] / exp) % 10]++;
    
    // Change count[i] so that count[i] contains actual
    // position of this digit in output[]
    for(int i = 1; i < 10; i++)
        count[i] += count[i - 1];
    
    // Build the output array
    for(int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
    
    // Copy the output array to arr[]
    for(int i = 0; i < n; i++)
        arr[i] = output[i];
}

void radixSort(std::vector&lt;int&gt;& arr) {
    // Find the maximum number to know number of digits
    int max_num = *std::max_element(arr.begin(), arr.end());
    
    // Do counting sort for every digit
    for(int exp = 1; max_num/exp > 0; exp *= 10)
        countingSortByDigit(arr, exp);
}

int main() {
    std::vector&lt;int&gt; arr = {170, 45, 75, 90, 802, 24, 2, 66};
    std::cout << "Original array: ";
    for(int num : arr) std::cout << num << " ";
    
    radixSort(arr);
    
    std::cout << "\nSorted array: ";
    for(int num : arr) std::cout << num << " ";
    return 0;
}
                                        </code></pre>
                                    </div>
                                </div>

                                <!-- C# Implementation -->
                                <div class="tab-pane fade" id="csharp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#csharp-code">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-csharp" id="csharp-code">
public class RadixSort
{
    private static void CountingSortByDigit(int[] arr, int exp)
    {
        int n = arr.Length;
        int[] output = new int[n];
        int[] count = new int[10];
        
        // Store count of occurrences in count[]
        for(int i = 0; i &lt; n; i++)
            count[(arr[i] / exp) % 10]++;
        
        // Change count[i] so that count[i] contains actual
        // position of this digit in output[]
        for(int i = 1; i &lt; 10; i++)
            count[i] += count[i - 1];
        
        // Build the output array
        for(int i = n - 1; i >= 0; i--)
        {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }
        
        // Copy the output array to arr[]
        for(int i = 0; i &lt; n; i++)
            arr[i] = output[i];
    }
    
    public static void Sort(int[] arr)
    {
        // Find the maximum number to know number of digits
        int max_num = arr.Max();
        
        // Do counting sort for every digit
        for(int exp = 1; max_num/exp > 0; exp *= 10)
            CountingSortByDigit(arr, exp);
    }
    
    public static void Main(string[] args)
    {
        int[] arr = { 170, 45, 75, 90, 802, 24, 2, 66 };
        Console.WriteLine("Original array: " + string.Join(" ", arr));
        
        Sort(arr);
        
        Console.WriteLine("Sorted array: " + string.Join(" ", arr));
    }
}
                                        </code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Applications</h2>
                        <ul>
                            <li>Sorting integers with fixed number of digits</li>
                            <li>Sorting strings of same length</li>
                            <li>Processing numerical data in scientific computing</li>
                            <li>Sorting dates and timestamps</li>
                            <li>Database indexing and sorting</li>
                        </ul>
                    </section>

                    <section class="algorithm-section">
                        <h2>Advantages and Disadvantages</h2>
                        <div class="pros-cons">
                            <div class="pros">
                                <h3>Advantages</h3>
                                <ul>
                                    <li>Linear time complexity for fixed-length integers</li>
                                    <li>Stable sorting algorithm</li>
                                    <li>Efficient for integers or strings with fixed-length</li>
                                    <li>Can be faster than comparison sorts</li>
                                </ul>
                            </div>
                            <div class="cons">
                                <h3>Disadvantages</h3>
                                <ul>
                                    <li>Not in-place sorting</li>
                                    <li>Requires extra space</li>
                                    <li>Only works with discrete values</li>
                                    <li>Performance depends on number of digits</li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Complexity Analysis</h2>
                        <div class="complexity-analysis">
                            <table class="complexity-table">
                                <tr>
                                    <th>Case</th>
                                    <th>Time Complexity</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <td>Best Case</td>
                                    <td>Ω(d * (n + k))</td>
                                    <td>When all numbers have same number of digits (d). Here, k is range of each digit
                                        (usually 10)</td>
                                </tr>
                                <tr>
                                    <td>Average Case</td>
                                    <td>Θ(d * (n + k))</td>
                                    <td>Same as best case, as number of operations doesn't depend on input arrangement
                                    </td>
                                </tr>
                                <tr>
                                    <td>Worst Case</td>
                                    <td>O(d * (n + k))</td>
                                    <td>When numbers have maximum possible digits (d)</td>
                                </tr>
                                <tr>
                                    <td>Space Complexity</td>
                                    <td>O(n + k)</td>
                                    <td>Requires temporary arrays for counting and output</td>
                                </tr>
                            </table>

                            <div class="complexity-notes">
                                <h3>Notes:</h3>
                                <ul>
                                    <li><strong>d</strong> - Number of digits in the largest number</li>
                                    <li><strong>n</strong> - Number of elements in the array</li>
                                    <li><strong>k</strong> - Range of values for each digit (typically 10 for decimal)
                                    </li>
                                    <li>Time complexity is linear when d is constant</li>
                                    <li>Performance depends heavily on number of digits in input numbers</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </article>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <div id="footer-placeholder"></div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script src="../../static/js/prism.js"></script>
    <script src="../../static/js/radixsort-visualization.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const clipboard = new ClipboardJS('.copy-button');

            clipboard.on('success', (e) => {
                const button = e.trigger;
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => {
                    button.innerHTML = '<i class="fas fa-copy"></i>';
                }, 2000);
                e.clearSelection();
            });
        });
    </script>
    <script src="../../static/js/templates.js"></script>
</body>

</html>