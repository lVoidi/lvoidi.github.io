<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Counting Sort Algorithm | Integer-based Linear Time Sorting Method</title>

    <!-- SEO Meta Tags -->
    <meta name="description"
        content="Learn the Counting Sort algorithm with O(n+k) time complexity. Includes interactive visualization and implementations in Python, C++, and C# for efficiently sorting arrays with small integer ranges.">
    <meta name="keywords"
        content="counting sort, integer sorting, non-comparative sort, linear time sort, stable sort, key-indexed counting, algorithm visualization">
    <meta name="author" content="lVoidi">
    <meta name="robots" content="index, follow">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://roarba.com/algorithms/sorting/countingsort.html">
    <meta property="og:title" content="Counting Sort Algorithm | Integer-based Linear Time Sorting Method">
    <meta property="og:description"
        content="Learn the Counting Sort algorithm with O(n+k) time complexity. Includes interactive visualization and implementations in Python, C++, and C# for efficiently sorting arrays with small integer ranges.">
    <meta property="og:image" content="https://roarba.com/static/img/algorithms/countingsort.jpg">

    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Counting Sort Algorithm | Integer-based Linear Time Sorting Method">
    <meta name="twitter:description"
        content="Learn the Counting Sort algorithm with O(n+k) time complexity. Includes interactive visualization and implementations in Python, C++, and C# for efficiently sorting arrays with small integer ranges.">
    <meta name="twitter:image" content="https://roarba.com/static/img/algorithms/countingsort.jpg">

    <!-- Canonical URL -->
    <meta rel="canonical" href="https://roarba.com/algorithms/sorting/countingsort.html">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="../../static/css/style.css" rel="stylesheet">
    <link href="../../static/css/algorithms.css" rel="stylesheet">
    <link href="../../static/css/singularity.css" rel="stylesheet">
    <link href="../../static/css/algorithm-page.css" rel="stylesheet">
    <link href="../../static/css/prism.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <!-- Icon -->
    <link rel="icon" href="../../static/img/icon.png" type="image/x-icon">

    <!-- Schema.org structured data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Counting Sort Algorithm | Integer-based Linear Time Sorting Method",
      "description": "Learn the Counting Sort algorithm with O(n+k) time complexity. Includes interactive visualization and implementations in Python, C++, and C# for efficiently sorting arrays with small integer ranges.",
      "image": "https://roarba.com/static/img/algorithms/countingsort.jpg",
      "author": {
        "@type": "Person",
        "name": "lVoidi"
      },
      "publisher": {
        "@type": "Organization",
        "name": "lVoidi Algorithm Portal",
        "logo": {
          "@type": "ImageObject",
          "url": "https://roarba.com/static/img/icon.png"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://roarba.com/algorithms/sorting/countingsort.html"
      },
      "about": {
        "@type": "Thing",
        "name": "Counting Sort Algorithm",
        "description": "A non-comparative sorting algorithm that works by counting the occurrences of each element and using that information to determine their positions in the output sequence."
      },
      "teaches": "Linear time sorting with integer keys",
      "educationalUse": "instruction",
      "timeRequired": "PT20M",
      "encodingFormat": "text/html",
      "programmingLanguage": ["Python", "C++", "C#"]
    }
    </script>
</head>

<body>
    <!-- Navbar -->
    <div id="navbar-placeholder"></div>

    <main class="container py-5">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3">
                <div class="algorithm-info-card">
                    <h3>Quick Info</h3>
                    <div class="info-item">
                        <span class="info-label">Category:</span>
                        <span class="info-value">Sorting</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Time Complexity:</span>
                        <span class="info-value">O(n + k)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Space Complexity:</span>
                        <span class="info-value">O(k)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Stable:</span>
                        <span class="info-value">Yes</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">In-Place:</span>
                        <span class="info-value">No</span>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <article class="algorithm-content">
                    <h1>Counting Sort</h1>
                    <div class="algorithm-metadata">
                        <span class="category-tag">Sorting</span>
                        <span class="difficulty-tag">Easy</span>
                    </div>

                    <section class="algorithm-section">
                        <h2>Description</h2>
                        <p>
                            Counting Sort is a non-comparison based sorting algorithm that operates on the principle of
                            counting the frequency of each distinct element in the input array. Unlike traditional
                            comparison-based
                            sorting algorithms like Quick Sort or Merge Sort, Counting Sort achieves linear time
                            complexity by
                            leveraging the integer nature of the elements and their known range.
                        </p>

                        <div class="definition-box">
                            <h4>Core Concept</h4>
                            <p>
                                The algorithm works by determining, for each input element, the number of elements that
                                are
                                less than it. This information is used to place the element directly into its correct
                                position
                                in the output array, making it particularly efficient for sorting integers within a
                                known range.
                            </p>
                        </div>

                        <p>
                            The process involves three main steps: first, counting the occurrences of each element;
                            second,
                            calculating cumulative counts to determine positions; and finally, building the sorted
                            output array
                            by placing each element in its correct position based on the count information.
                        </p>

                        <p>
                            One of the key characteristics of Counting Sort is its <strong>stability</strong> - elements
                            with
                            equal values appear in the same relative order in the output as they did in the input. This
                            property
                            makes it particularly valuable as a subroutine in other algorithms, most notably Radix Sort,
                            where
                            maintaining the relative order of elements is crucial.
                        </p>

                        <div class="definition-box">
                            <h4>When to Use Counting Sort</h4>
                            <p>
                                Counting Sort is most effective when the range of input values (k) is not significantly
                                larger
                                than the number of elements to be sorted (n). If k = O(n), the algorithm runs in O(n)
                                time,
                                making it faster than any comparison-based sorting algorithm, which has a lower bound of
                                O(n log n).
                            </p>
                        </div>

                        <p>
                            However, the algorithm has limitations: it requires additional space proportional to the
                            range of
                            input values, and it only works efficiently with discrete values (typically integers). When
                            the range
                            is very large compared to the number of elements, or when dealing with floating-point
                            numbers or
                            complex objects, other sorting algorithms may be more appropriate.
                        </p>
                    </section>

                    <section class="algorithm-section history-box">
                        <h2>History</h2>
                        <div class="history-content">
                            <img src="../../static/img/counting-sort.jpg" alt="Counting Sort Concept"
                                class="history-image">
                            <p>
                                Counting Sort emerged in the early days of computer science, during the 1950s, when
                                researchers were exploring non-comparison based sorting methods. Unlike many other
                                sorting algorithms that are named after their inventors, Counting Sort is named after
                                its process of counting elements.

                                The algorithm gained prominence as a subroutine in Radix Sort, where it's used to sort
                                numbers digit by digit. Its ability to sort in linear time made it particularly valuable
                                in specific applications where the range of input values is known and reasonably small
                                compared to the number of items to be sorted.

                                The algorithm has found widespread use in various applications, from sorting postal
                                codes to computer graphics rendering pipelines where elements need to be sorted by depth
                                (z-index).
                            </p>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>How It Works</h2>
                        <p>
                            Counting Sort operates through a series of well-defined steps that transform the input array
                            into a sorted output. The algorithm's elegance lies in its ability to determine the exact
                            position of each element without performing any comparisons between elements.
                        </p>

                        <h3>Step 1: Determine the Range</h3>
                        <p>
                            The first step is to identify the minimum and maximum values in the input array. This range
                            determines the size of the counting array needed. For example, if the input contains values
                            from 5 to 20, we need a counting array of size 16 (20 - 5 + 1).
                        </p>

                        <div class="definition-box">
                            <h4>Why Range Matters</h4>
                            <p>
                                The range directly impacts both space and time complexity. If the range is too large
                                (e.g., sorting 10 numbers between 1 and 1,000,000), the algorithm becomes inefficient
                                due to the large counting array needed. This is why Counting Sort is best suited for
                                scenarios where k ≈ n.
                            </p>
                        </div>

                        <h3>Step 2: Count Frequencies</h3>
                        <p>
                            Create a count array of size k (the range) and initialize all values to 0. Then, iterate
                            through the input array and increment the count for each element. For instance, if the value
                            7 appears three times in the input, count[7 - min_val] will be 3.
                        </p>
                        <pre><code>Example:
Input:  [4, 2, 2, 8, 3, 3, 1]
Count:  [1, 2, 2, 1, 0, 0, 0, 1]
Index:   1  2  3  4  5  6  7  8</code></pre>

                        <h3>Step 3: Calculate Cumulative Counts</h3>
                        <p>
                            Transform the count array into a cumulative count array by adding each element to the sum of
                            all previous elements. This step is crucial as it determines the final position of each
                            element in the sorted array. After this transformation, count[i] represents the number of
                            elements less than or equal to i.
                        </p>
                        <pre><code>Example (continuing from above):
Count after cumulative:  [1, 3, 5, 6, 6, 6, 6, 7]
Meaning: There are 3 elements ≤ 2, 5 elements ≤ 3, etc.</code></pre>

                        <div class="definition-box">
                            <h4>Understanding Cumulative Counts</h4>
                            <p>
                                The cumulative count at position i tells us exactly where the last occurrence of value i
                                should be placed in the output array. By working backwards through the input array and
                                decrementing counts after each placement, we preserve the stability of the sort.
                            </p>
                        </div>

                        <h3>Step 4: Build the Sorted Output</h3>
                        <p>
                            Create an output array of the same size as the input. Iterate through the input array from
                            right to left (to maintain stability). For each element, place it at the position indicated
                            by its cumulative count, then decrement that count. Working backwards ensures that if two
                            elements have the same value, the one that appeared later in the input will be placed later
                            in the output.
                        </p>
                        <pre><code>Example (final step):
Processing from right to left: [4, 2, 2, 8, 3, 3, 1]
Output: [1, 2, 2, 3, 3, 4, 8]</code></pre>

                        <h3>Step 5: Copy Back to Input Array</h3>
                        <p>
                            Finally, copy the sorted output array back to the original input array. This step completes
                            the sorting process.
                        </p>

                        <div class="definition-box">
                            <h4>Why Work Backwards?</h4>
                            <p>
                                Iterating from right to left in Step 4 is what makes Counting Sort stable. When elements
                                with equal values are encountered, they are placed in reverse order of their appearance
                                in the input, which means they end up in the same relative order in the output. This
                                stability property is essential for algorithms like Radix Sort that rely on Counting
                                Sort as a subroutine.
                            </p>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Visualization</h2>
                        <div class="visualization-container">
                            <div class="visualization-controls">
                                <button class="btn btn-primary" id="startVisualization">
                                    <i class="fas fa-play"></i> Start
                                </button>
                                <button class="btn btn-secondary" id="resetVisualization">
                                    <i class="fas fa-redo"></i> Reset
                                </button>
                                <div class="speed-control">
                                    <label>Speed:</label>
                                    <input type="range" id="speedControl" min="1" max="5" value="3">
                                </div>
                            </div>
                            <div class="visualization-area">
                                <svg id="countingSortVisualization" width="100%" height="400"></svg>
                            </div>
                            <div class="visualization-steps">
                                <p id="currentStep">Click Start to begin visualization</p>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Implementation</h2>
                        <div class="implementation-tabs">
                            <ul class="nav nav-tabs" role="tablist">
                                <li class="nav-item">
                                    <a class="nav-link active" data-bs-toggle="tab" href="#python">Python</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#cpp">C++</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" data-bs-toggle="tab" href="#csharp">C#</a>
                                </li>
                            </ul>
                            <div class="tab-content">
                                <div class="tab-pane fade show active" id="python">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#python-code">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-python" id="python-code">
def counting_sort(arr):
    # Find the range of input array
    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1
    
    # Initialize count array and output array
    count = [0] * range_val
    output = [0] * len(arr)
    
    # Store count of each element
    for i in arr:
        count[i - min_val] += 1
    
    # Modify count array to store actual positions
    for i in range(1, len(count)):
        count[i] += count[i - 1]
    
    # Build output array
    for i in range(len(arr) - 1, -1, -1):
        output[count[arr[i] - min_val] - 1] = arr[i]
        count[arr[i] - min_val] -= 1
    
    # Copy output array to input array
    for i in range(len(arr)):
        arr[i] = output[i]
    
    return arr
                                        </code></pre>
                                    </div>
                                </div>
                                <div class="tab-pane fade" id="cpp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#cpp-code">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-cpp" id="cpp-code">
void countingSort(vector<int>& arr) {
    // Find range of array elements
    int max_val = *max_element(arr.begin(), arr.end());
    int min_val = *min_element(arr.begin(), arr.end());
    int range = max_val - min_val + 1;
    
    // Create count array and output array
    vector<int> count(range), output(arr.size());
    
    // Store count of each element
    for(int i = 0; i < arr.size(); i++)
        count[arr[i] - min_val]++;
        
    // Modify count array to store actual positions
    for(int i = 1; i < count.size(); i++)
        count[i] += count[i-1];
        
    // Build output array
    for(int i = arr.size()-1; i >= 0; i--) {
        output[count[arr[i] - min_val] - 1] = arr[i];
        count[arr[i] - min_val]--;
    }
    
    // Copy output array to input array
    for(int i = 0; i < arr.size(); i++)
        arr[i] = output[i];
}

// Example usage
int main() {
    vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    cout << "Original array: ";
    for(int num : arr) cout << num << " ";
    
    countingSort(arr);
    
    cout << "\nSorted array: ";
    for(int num : arr) cout << num << " ";
    return 0;
}
                                        </code></pre>
                                    </div>
                                </div>
                                <div class="tab-pane fade" id="csharp">
                                    <div class="code-wrapper">
                                        <button class="copy-button" data-clipboard-target="#csharp-code">
                                            <i class="fas fa-copy"></i>
                                        </button>
                                        <pre><code class="language-csharp" id="csharp-code">
public class CountingSort
{
    public static void Sort(int[] arr)
    {
        // Find range of array elements
        int maxVal = arr.Max();
        int minVal = arr.Min();
        int range = maxVal - minVal + 1;
        
        // Create count array and output array
        int[] count = new int[range];
        int[] output = new int[arr.Length];
        
        // Store count of each element
        for(int i = 0; i < arr.Length; i++)
            count[arr[i] - minVal]++;
            
        // Modify count array to store actual positions
        for(int i = 1; i < count.Length; i++)
            count[i] += count[i - 1];
            
        // Build output array
        for(int i = arr.Length - 1; i >= 0; i--)
        {
            output[count[arr[i] - minVal] - 1] = arr[i];
            count[arr[i] - minVal]--;
        }
        
        // Copy output array to input array
        for(int i = 0; i < arr.Length; i++)
            arr[i] = output[i];
    }
    
    // Example usage
    public static void Main(string[] args)
    {
        int[] arr = { 64, 34, 25, 12, 22, 11, 90 };
        Console.WriteLine("Original array: " + string.Join(" ", arr));
        
        Sort(arr);
        
        Console.WriteLine("Sorted array: " + string.Join(" ", arr));
    }
}
                                        </code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Applications</h2>
                        <ul>
                            <li>Sorting integers with known range</li>
                            <li>Sorting postal codes</li>
                            <li>Sorting strings (as part of radix sort)</li>
                            <li>Computer graphics (sorting by z-index)</li>
                            <li>DNA sequence analysis</li>
                        </ul>
                    </section>

                    <section class="algorithm-section">
                        <h2>Advantages and Disadvantages</h2>
                        <div class="pros-cons">
                            <div class="pros">
                                <h3>Advantages</h3>
                                <ul>
                                    <li>Linear time complexity O(n + k)</li>
                                    <li>Stable sorting algorithm</li>
                                    <li>Efficient for integers with known range</li>
                                    <li>Good as a subroutine in radix sort</li>
                                </ul>
                            </div>
                            <div class="cons">
                                <h3>Disadvantages</h3>
                                <ul>
                                    <li>Not in-place sorting</li>
                                    <li>Requires extra space O(k)</li>
                                    <li>Only works with discrete values</li>
                                    <li>Not efficient when range k is much larger than n</li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Complexity Analysis</h2>
                        <div class="complexity-analysis">
                            <table class="complexity-table">
                                <tr>
                                    <th>Case</th>
                                    <th>Time Complexity</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <td>Best Case</td>
                                    <td>Ω(n + k)</td>
                                    <td>Always performs same operations regardless of input arrangement</td>
                                </tr>
                                <tr>
                                    <td>Average Case</td>
                                    <td>Θ(n + k)</td>
                                    <td>Requires two passes through array of size n and one through count array of size
                                        k</td>
                                </tr>
                                <tr>
                                    <td>Worst Case</td>
                                    <td>O(n + k)</td>
                                    <td>Same as other cases due to non-comparative nature</td>
                                </tr>
                                <tr>
                                    <td>Space Complexity</td>
                                    <td>O(k)</td>
                                    <td>Requires count array of size k and output array of size n</td>
                                </tr>
                            </table>

                            <div class="complexity-notes">
                                <h3>Notes:</h3>
                                <ul>
                                    <li><strong>n</strong> - Number of elements in the input array</li>
                                    <li><strong>k</strong> - Range of input (max - min + 1)</li>
                                    <li>Linear time complexity when k = O(n)</li>
                                    <li>Not efficient when k >> n (range much larger than array size)</li>
                                    <li>Performance independent of input distribution</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </article>
            </div>
        </div>
    </main>

    <div id="footer-placeholder"></div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script src="../../static/js/prism.js"></script>
    <script src="../../static/js/countingsort-visualization.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const clipboard = new ClipboardJS('.copy-button');

            clipboard.on('success', (e) => {
                const button = e.trigger;
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => {
                    button.innerHTML = '<i class="fas fa-copy"></i>';
                }, 2000);
                e.clearSelection();
            });
        });
    </script>
    <script src="../../static/js/templates.js"></script>
</body>

</html>