<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markov Chain Text Generation | Stochastic String Processing Algorithm</title>

    <!-- SEO Meta Tags -->
    <meta name="description"
        content="Learn about Markov Chain text generation with O(n) time complexity. Includes interactive demo and implementations in Python, C++, and C# for generating realistic text based on probabilistic models.">
    <meta name="keywords"
        content="markov chain, text generation, natural language processing, stochastic model, probabilistic algorithm, predictive text, state transitions, NLP, computer science, algorithm visualization">
    <meta name="author" content="Rodrigo Arce">
    <meta name="robots" content="index, follow">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://roarba.com/algorithms/string/markov.html">
    <meta property="og:title" content="Markov Chain Text Generation | Stochastic String Processing Algorithm">
    <meta property="og:description"
        content="Learn about Markov Chain text generation with O(n) time complexity. Includes interactive demo and implementations in Python, C++, and C# for generating realistic text based on probabilistic models.">
    <meta property="og:image" content="https://roarba.com/static/img/algorithms/markov.jpg">

    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Markov Chain Text Generation | Stochastic String Processing Algorithm">
    <meta name="twitter:description"
        content="Learn about Markov Chain text generation with O(n) time complexity. Includes interactive demo and implementations in Python, C++, and C# for generating realistic text based on probabilistic models.">
    <meta name="twitter:image" content="https://roarba.com/static/img/algorithms/markov.jpg">

    <!-- Canonical URL -->
    <meta rel="canonical" href="https://roarba.com/algorithms/string/markov.html">

    <!-- CSS imports -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="../../static/css/style.css" rel="stylesheet">
    <link href="../../static/css/algorithms.css" rel="stylesheet">
    <link href="../../static/css/algorithm-page.css" rel="stylesheet">
    <link href="../../static/css/singularity.css" rel="stylesheet">
    <link href="../../static/css/prism.css" rel="stylesheet">

    <!-- Icon -->
    <link rel="icon" href="../../static/img/icon.png" type="image/x-icon">

    <!-- Schema.org structured data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Markov Chain Text Generation | Stochastic String Processing Algorithm",
      "description": "Learn about Markov Chain text generation with O(n) time complexity. Includes interactive demo and implementations in Python, C++, and C# for generating realistic text based on probabilistic models.",
      "image": "https://roarba.com/static/img/algorithms/markov.jpg",
      "author": {
        "@type": "Person",
        "name": "lVoidi"
      },
      "publisher": {
        "@type": "Organization",
        "name": "lVoidi Algorithm Portal",
        "logo": {
          "@type": "ImageObject",
          "url": "https://roarba.com/static/img/icon.png"
        }
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://roarba.com/algorithms/string/markov.html"
      },
      "about": {
        "@type": "Thing",
        "name": "Markov Chain Text Generation",
        "description": "A stochastic model that describes sequences of possible events where the probability of each event depends only on the state of the previous event, used for generating realistic text."
      },
      "teaches": "Probabilistic text generation using state transitions",
      "educationalUse": "instruction",
      "timeRequired": "PT20M",
      "encodingFormat": "text/html",
      "programmingLanguage": ["Python", "C++", "C#"]
    }
    </script>
</head>

<body>
    <div id="navbar-placeholder"></div>

    <main class="container py-5">
        <div class="row">
            <!-- Sidebar with Quick Info -->
            <div class="col-md-3">
                <div class="algorithm-info-card">
                    <h3>Quick Info</h3>
                    <div class="info-item">
                        <span class="info-label">Category:</span>
                        <span class="info-value">String Processing</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Time Complexity:</span>
                        <span class="info-value">O(n)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Space Complexity:</span>
                        <span class="info-value">O(k)</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Input Type:</span>
                        <span class="info-value">Text</span>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <article class="algorithm-content">
                    <h1>Markov Chain Text Generation</h1>
                    <div class="algorithm-metadata">
                        <span class="category-tag">String</span>
                        <span class="difficulty-tag">Medium</span>
                    </div>

                    <section class="algorithm-section">
                        <h2>Description</h2>
                        <p>A Markov Chain is a stochastic model that describes a sequence of possible events where the
                            probability of each event depends only on the state of the previous event. In text
                            generation, it's used to predict the next word or character based on the previous n words or
                            characters.</p>
                    </section>

                    <section class="algorithm-section">
                        <h2>How It Works</h2>
                        <ol>
                            <li>Training Phase:
                                <ul>
                                    <li>Analyze input text to build state transitions</li>
                                    <li>Create a probability distribution for each state</li>
                                    <li>Store transitions in a dictionary/map structure</li>
                                </ul>
                            </li>
                            <li>Generation Phase:
                                <ul>
                                    <li>Start with an initial state</li>
                                    <li>Randomly select next state based on probabilities</li>
                                    <li>Repeat until desired length or end condition</li>
                                </ul>
                            </li>
                        </ol>
                    </section>

                    <section class="algorithm-section">
                        <h2>Visualization</h2>
                        <div class="visualization-container">
                            <div class="visualization-controls">
                                <div class="input-group mb-3">
                                    <textarea id="trainingText" class="form-control" placeholder="Enter training text"
                                        rows="4"></textarea>
                                </div>
                                <div class="input-group mb-3">
                                    <input type="number" id="chainLength" class="form-control"
                                        placeholder="Chain length" value="2" min="1" max="5">
                                    <input type="number" id="outputLength" class="form-control"
                                        placeholder="Output length" value="100" min="10">
                                    <button class="btn btn-primary" id="generateBtn">Generate</button>
                                    <button class="btn btn-secondary" id="resetBtn">Reset</button>
                                </div>
                            </div>
                            <div class="visualization-area">
                                <div id="markovOutput" class="output-text"></div>
                            </div>
                        </div>
                    </section>

                    <div class="implementation-tabs">
                        <ul class="nav nav-tabs" role="tablist">
                            <li class="nav-item">
                                <a class="nav-link active" data-bs-toggle="tab" href="#python">Python</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" data-bs-toggle="tab" href="#cpp">C++</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" data-bs-toggle="tab" href="#csharp">C#</a>
                            </li>
                        </ul>
                        <div class="tab-content">
                            <!-- Python Implementation -->
                            <div class="tab-pane fade show active" id="python">
                                <div class="code-wrapper">
                                    <button class="copy-button" data-clipboard-target="#code-block-python">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                    <pre><code class="language-python" id="code-block-python">
from collections import defaultdict
import random
from typing import Dict, List, Tuple

class MarkovChain:
    def __init__(self, order: int = 2):
        """Initialize Markov Chain with specified order (chain length)."""
        self.order = order
        self.transitions = defaultdict(list)
        
    def train(self, text: str) -> None:
        """Train the Markov Chain on input text."""
        # Add padding to handle start/end
        padded_text = " " * self.order + text + " " * self.order
        
        # Build transitions dictionary
        for i in range(len(padded_text) - self.order):
            state = padded_text[i:i + self.order]
            next_char = padded_text[i + self.order]
            self.transitions[state].append(next_char)
    
    def generate(self, length: int = 100) -> str:
        """Generate text using the trained Markov Chain."""
        if not self.transitions:
            return "Error: Model not trained"
        
        # Start with a random state
        current = random.choice(list(self.transitions.keys()))
        result = list(current)
        
        # Generate subsequent characters
        for _ in range(length - self.order):
            if current not in self.transitions:
                break
                
            next_char = random.choice(self.transitions[current])
            result.append(next_char)
            current = current[1:] + next_char
        
        return ''.join(result).strip()
    
    def get_statistics(self) -> Dict[str, int]:
        """Get statistics about the trained model."""
        return {
            'states': len(self.transitions),
            'total_transitions': sum(len(v) for v in self.transitions.values()),
            'avg_transitions': sum(len(v) for v in self.transitions.values()) / 
                             len(self.transitions) if self.transitions else 0
        }

def main():
    # Example usage
    text = """
    The quick brown fox jumps over the lazy dog.
    A quick brown dog jumps over the lazy fox.
    The lazy fox and dog are quick to jump.
    """
    
    # Create and train model
    markov = MarkovChain(order=2)
    markov.train(text)
    
    # Generate text
    generated = markov.generate(length=100)
    print("Generated text:")
    print(generated)
    
    # Print statistics
    stats = markov.get_statistics()
    print("\nModel Statistics:")
    for key, value in stats.items():
        print(f"{key}: {value}")

if __name__ == "__main__":
    main()
</code></pre>
                                </div>
                            </div>

                            <!-- C++ Implementation -->
                            <div class="tab-pane fade" id="cpp">
                                <div class="code-wrapper">
                                    <button class="copy-button" data-clipboard-target="#code-block-cpp">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                    <pre><code class="language-cpp" id="code-block-cpp">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;random&gt;
#include &lt;chrono&gt;

class MarkovChain {
private:
    int order;
    std::map&lt;std::string, std::vector&lt;char&gt;&gt; transitions;
    std::mt19937 rng;

public:
    MarkovChain(int chainOrder = 2) : order(chainOrder) {
        // Initialize random number generator with time-based seed
        rng.seed(std::chrono::steady_clock::now().time_since_epoch().count());
    }

    void train(const std::string& text) {
        // Add padding to handle start/end
        std::string paddedText = std::string(order, ' ') + text + std::string(order, ' ');

        // Build transitions map
        for (size_t i = 0; i < paddedText.length() - order; ++i) {
            std::string state = paddedText.substr(i, order);
            char nextChar = paddedText[i + order];
            transitions[state].push_back(nextChar);
        }
    }

    std::string generate(size_t length = 100) {
        if (transitions.empty()) {
            return "Error: Model not trained";
        }

        // Start with a random state
        std::vector&lt;std::string&gt; states;
        for (const auto& pair : transitions) {
            states.push_back(pair.first);
        }
        
        std::uniform_int_distribution&lt;size_t&gt; stateDist(0, states.size() - 1);
        std::string current = states[stateDist(rng)];
        std::string result = current;

        // Generate subsequent characters
        for (size_t i = 0; i < length - order; ++i) {
            auto it = transitions.find(current);
            if (it == transitions.end() || it->second.empty()) {
                break;
            }

            std::uniform_int_distribution&lt;size_t&gt; charDist(0, it->second.size() - 1);
            char nextChar = it->second[charDist(rng)];
            result += nextChar;
            current = result.substr(result.length() - order);
        }

        return result;
    }

    void printStats() const {
        size_t totalTransitions = 0;
        for (const auto& pair : transitions) {
            totalTransitions += pair.second.size();
        }

        std::cout << "Model Statistics:\n";
        std::cout << "States: " << transitions.size() << "\n";
        std::cout << "Total transitions: " << totalTransitions << "\n";
        std::cout << "Average transitions per state: " 
                  << (transitions.empty() ? 0.0 : 
                      static_cast&lt;double&gt;(totalTransitions) / transitions.size())
                  << "\n";
    }
};

int main() {
    std::string text = R"(
        The quick brown fox jumps over the lazy dog.
        A quick brown dog jumps over the lazy fox.
        The lazy fox and dog are quick to jump.
    )";

    MarkovChain markov(2);
    markov.train(text);

    std::cout << "Generated text:\n";
    std::cout << markov.generate(100) << "\n\n";

    markov.printStats();

    return 0;
}
</code></pre>
                                </div>
                            </div>

                            <!-- C# Implementation -->
                            <div class="tab-pane fade" id="csharp">
                                <div class="code-wrapper">
                                    <button class="copy-button" data-clipboard-target="#code-block-csharp">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                    <pre><code class="language-csharp" id="code-block-csharp">
using System;
using System.Collections.Generic;
using System.Linq;

public class MarkovChain
{
    private readonly int order;
    private readonly Dictionary&lt;string, List&lt;char&gt;&gt; transitions;
    private readonly Random random;

    public MarkovChain(int order = 2)
    {
        this.order = order;
        this.transitions = new Dictionary&lt;string, List&lt;char&gt;&gt;();
        this.random = new Random();
    }

    public void Train(string text)
    {
        // Add padding to handle start/end
        string paddedText = new string(' ', order) + text + new string(' ', order);

        // Build transitions dictionary
        for (int i = 0; i < paddedText.Length - order; i++)
        {
            string state = paddedText.Substring(i, order);
            char nextChar = paddedText[i + order];

            if (!transitions.ContainsKey(state))
            {
                transitions[state] = new List&lt;char&gt;();
            }
            transitions[state].Add(nextChar);
        }
    }

    public string Generate(int length = 100)
    {
        if (!transitions.Any())
        {
            return "Error: Model not trained";
        }

        // Start with a random state
        string current = transitions.Keys.ElementAt(random.Next(transitions.Count));
        var result = new List&lt;char&gt;(current);

        // Generate subsequent characters
        for (int i = 0; i < length - order; i++)
        {
            if (!transitions.ContainsKey(current))
            {
                break;
            }

            var possibleNextChars = transitions[current];
            char nextChar = possibleNextChars[random.Next(possibleNextChars.Count)];
            result.Add(nextChar);
            current = new string(result.Skip(result.Count - order).Take(order).ToArray());
        }

        return new string(result.ToArray()).Trim();
    }

    public Dictionary&lt;string, object&gt; GetStatistics()
    {
        int totalTransitions = transitions.Values.Sum(v => v.Count);
        double avgTransitions = transitions.Any() 
            ? (double)totalTransitions / transitions.Count 
            : 0;

        return new Dictionary&lt;string, object&gt;
        {
            ["States"] = transitions.Count,
            ["TotalTransitions"] = totalTransitions,
            ["AverageTransitionsPerState"] = avgTransitions
        };
    }

    public static void Main()
    {
        string text = @"
            The quick brown fox jumps over the lazy dog.
            A quick brown dog jumps over the lazy fox.
            The lazy fox and dog are quick to jump.
        ";

        var markov = new MarkovChain(2);
        markov.Train(text);

        Console.WriteLine("Generated text:");
        Console.WriteLine(markov.Generate(100));
        Console.WriteLine();

        var stats = markov.GetStatistics();
        Console.WriteLine("Model Statistics:");
        foreach (var stat in stats)
        {
            Console.WriteLine($"{stat.Key}: {stat.Value}");
        }
    }
}
</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>

                    <section class="algorithm-section">
                        <h2>Complexity Analysis</h2>
                        <div class="complexity-analysis">
                            <h3>Time Complexity</h3>
                            <ul>
                                <li><strong>Training:</strong> O(n), where n is the length of input text</li>
                                <li><strong>Generation:</strong> O(m), where m is the desired output length</li>
                            </ul>

                            <h3>Space Complexity</h3>
                            <ul>
                                <li><strong>O(k)</strong>, where k is the number of unique states</li>
                                <li>k depends on the order of the Markov chain and input text variety</li>
                            </ul>
                        </div>
                    </section>

                    <section class="algorithm-section">
                        <h2>Applications</h2>
                        <ul>
                            <li>Text Generation</li>
                            <li>Predictive Text</li>
                            <li>Language Modeling</li>
                            <li>Speech Synthesis</li>
                            <li>Music Composition</li>
                        </ul>
                    </section>

                    <section class="algorithm-section">
                        <h2>Advantages and Disadvantages</h2>
                        <div class="pros-cons">
                            <div class="pros">
                                <h3>Advantages</h3>
                                <ul>
                                    <li>Simple to implement</li>
                                    <li>Fast training and generation</li>
                                    <li>Memory efficient</li>
                                    <li>Works with any sequence data</li>
                                </ul>
                            </div>
                            <div class="cons">
                                <h3>Disadvantages</h3>
                                <ul>
                                    <li>Limited context understanding</li>
                                    <li>Can produce nonsensical output</li>
                                    <li>No long-term dependencies</li>
                                    <li>Requires large training data</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </article>
            </div>
        </div>
    </main>

    <div id="footer-placeholder"></div>
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script src="../../static/js/prism.js"></script>
    <script src="../../static/js/markov-visualization.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const clipboard = new ClipboardJS('.copy-button');

            clipboard.on('success', (e) => {
                const button = e.trigger;
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => {
                    button.innerHTML = '<i class="fas fa-copy"></i>';
                }, 2000);
                e.clearSelection();
            });
        });
    </script>
    <script src="../../static/js/templates.js"></script>
</body>

</html>